        -:    0:Source:/home/nikolas/Programming/repos/im-c/tests/build/_deps/unity-src/src/unity.c
        -:    0:Graph:build/CMakeFiles/test_error_handling.dir/_deps/unity-src/src/unity.c.gcno
        -:    0:Data:build/CMakeFiles/test_error_handling.dir/_deps/unity-src/src/unity.c.gcda
        -:    0:Runs:2
        -:    1:/* =========================================================================
        -:    2:    Unity Project - A Test Framework for C
        -:    3:    Copyright (c) 2007-21 Mike Karlesky, Mark VanderVoord, Greg Williams
        -:    4:    [Released under MIT License. Please refer to license.txt for details]
        -:    5:============================================================================ */
        -:    6:
        -:    7:#include "unity.h"
        -:    8:#include <stddef.h>
        -:    9:
        -:   10:#ifdef AVR
        -:   11:#include <avr/pgmspace.h>
        -:   12:#else
        -:   13:#define PROGMEM
        -:   14:#endif
        -:   15:
        -:   16:/* If omitted from header, declare overrideable prototypes here so they're ready for use */
        -:   17:#ifdef UNITY_OMIT_OUTPUT_CHAR_HEADER_DECLARATION
        -:   18:void UNITY_OUTPUT_CHAR(int);
        -:   19:#endif
        -:   20:
        -:   21:/* Helpful macros for us to use here in Assert functions */
        -:   22:#define UNITY_FAIL_AND_BAIL   { Unity.CurrentTestFailed  = 1; UNITY_OUTPUT_FLUSH(); TEST_ABORT(); }
        -:   23:#define UNITY_IGNORE_AND_BAIL { Unity.CurrentTestIgnored = 1; UNITY_OUTPUT_FLUSH(); TEST_ABORT(); }
        -:   24:#define RETURN_IF_FAIL_OR_IGNORE if (Unity.CurrentTestFailed || Unity.CurrentTestIgnored) TEST_ABORT()
        -:   25:
        -:   26:struct UNITY_STORAGE_T Unity;
        -:   27:
        -:   28:#ifdef UNITY_OUTPUT_COLOR
        -:   29:const char PROGMEM UnityStrOk[]                            = "\033[42mOK\033[00m";
        -:   30:const char PROGMEM UnityStrPass[]                          = "\033[42mPASS\033[00m";
        -:   31:const char PROGMEM UnityStrFail[]                          = "\033[41mFAIL\033[00m";
        -:   32:const char PROGMEM UnityStrIgnore[]                        = "\033[43mIGNORE\033[00m";
        -:   33:#else
        -:   34:const char PROGMEM UnityStrOk[]                            = "OK";
        -:   35:const char PROGMEM UnityStrPass[]                          = "PASS";
        -:   36:const char PROGMEM UnityStrFail[]                          = "FAIL";
        -:   37:const char PROGMEM UnityStrIgnore[]                        = "IGNORE";
        -:   38:#endif
        -:   39:static const char PROGMEM UnityStrNull[]                   = "NULL";
        -:   40:static const char PROGMEM UnityStrSpacer[]                 = ". ";
        -:   41:static const char PROGMEM UnityStrExpected[]               = " Expected ";
        -:   42:static const char PROGMEM UnityStrWas[]                    = " Was ";
        -:   43:static const char PROGMEM UnityStrGt[]                     = " to be greater than ";
        -:   44:static const char PROGMEM UnityStrLt[]                     = " to be less than ";
        -:   45:static const char PROGMEM UnityStrOrEqual[]                = "or equal to ";
        -:   46:static const char PROGMEM UnityStrNotEqual[]               = " to be not equal to ";
        -:   47:static const char PROGMEM UnityStrElement[]                = " Element ";
        -:   48:static const char PROGMEM UnityStrByte[]                   = " Byte ";
        -:   49:static const char PROGMEM UnityStrMemory[]                 = " Memory Mismatch.";
        -:   50:static const char PROGMEM UnityStrDelta[]                  = " Values Not Within Delta ";
        -:   51:static const char PROGMEM UnityStrPointless[]              = " You Asked Me To Compare Nothing, Which Was Pointless.";
        -:   52:static const char PROGMEM UnityStrNullPointerForExpected[] = " Expected pointer to be NULL";
        -:   53:static const char PROGMEM UnityStrNullPointerForActual[]   = " Actual pointer was NULL";
        -:   54:#ifndef UNITY_EXCLUDE_FLOAT
        -:   55:static const char PROGMEM UnityStrNot[]                    = "Not ";
        -:   56:static const char PROGMEM UnityStrInf[]                    = "Infinity";
        -:   57:static const char PROGMEM UnityStrNegInf[]                 = "Negative Infinity";
        -:   58:static const char PROGMEM UnityStrNaN[]                    = "NaN";
        -:   59:static const char PROGMEM UnityStrDet[]                    = "Determinate";
        -:   60:static const char PROGMEM UnityStrInvalidFloatTrait[]      = "Invalid Float Trait";
        -:   61:#endif
        -:   62:const char PROGMEM UnityStrErrShorthand[]                  = "Unity Shorthand Support Disabled";
        -:   63:const char PROGMEM UnityStrErrFloat[]                      = "Unity Floating Point Disabled";
        -:   64:const char PROGMEM UnityStrErrDouble[]                     = "Unity Double Precision Disabled";
        -:   65:const char PROGMEM UnityStrErr64[]                         = "Unity 64-bit Support Disabled";
        -:   66:static const char PROGMEM UnityStrBreaker[]                = "-----------------------";
        -:   67:static const char PROGMEM UnityStrResultsTests[]           = " Tests ";
        -:   68:static const char PROGMEM UnityStrResultsFailures[]        = " Failures ";
        -:   69:static const char PROGMEM UnityStrResultsIgnored[]         = " Ignored ";
        -:   70:#ifndef UNITY_EXCLUDE_DETAILS
        -:   71:static const char PROGMEM UnityStrDetail1Name[]            = UNITY_DETAIL1_NAME " ";
        -:   72:static const char PROGMEM UnityStrDetail2Name[]            = " " UNITY_DETAIL2_NAME " ";
        -:   73:#endif
        -:   74:/*-----------------------------------------------
        -:   75: * Pretty Printers & Test Result Output Handlers
        -:   76: *-----------------------------------------------*/
        -:   77:
        -:   78:/*-----------------------------------------------*/
        -:   79:/* Local helper function to print characters. */
     5854:   80:static void UnityPrintChar(const char* pch)
        -:   81:{
        -:   82:    /* printable characters plus CR & LF are printed */
     5854:   83:    if ((*pch <= 126) && (*pch >= 32))
        -:   84:    {
     5854:   85:        UNITY_OUTPUT_CHAR(*pch);
        -:   86:    }
        -:   87:    /* write escaped carriage returns */
    #####:   88:    else if (*pch == 13)
        -:   89:    {
    #####:   90:        UNITY_OUTPUT_CHAR('\\');
    #####:   91:        UNITY_OUTPUT_CHAR('r');
        -:   92:    }
        -:   93:    /* write escaped line feeds */
    #####:   94:    else if (*pch == 10)
        -:   95:    {
    #####:   96:        UNITY_OUTPUT_CHAR('\\');
    #####:   97:        UNITY_OUTPUT_CHAR('n');
        -:   98:    }
        -:   99:    /* unprintable characters are shown as codes */
        -:  100:    else
        -:  101:    {
    #####:  102:        UNITY_OUTPUT_CHAR('\\');
    #####:  103:        UNITY_OUTPUT_CHAR('x');
    #####:  104:        UnityPrintNumberHex((UNITY_UINT)*pch, 2);
        -:  105:    }
     5854:  106:}
        -:  107:
        -:  108:/*-----------------------------------------------*/
        -:  109:/* Local helper function to print ANSI escape strings e.g. "\033[42m". */
        -:  110:#ifdef UNITY_OUTPUT_COLOR
        -:  111:static UNITY_UINT UnityPrintAnsiEscapeString(const char* string)
        -:  112:{
        -:  113:    const char* pch = string;
        -:  114:    UNITY_UINT count = 0;
        -:  115:
        -:  116:    while (*pch && (*pch != 'm'))
        -:  117:    {
        -:  118:        UNITY_OUTPUT_CHAR(*pch);
        -:  119:        pch++;
        -:  120:        count++;
        -:  121:    }
        -:  122:    UNITY_OUTPUT_CHAR('m');
        -:  123:    count++;
        -:  124:
        -:  125:    return count;
        -:  126:}
        -:  127:#endif
        -:  128:
        -:  129:/*-----------------------------------------------*/
      166:  130:void UnityPrint(const char* string)
        -:  131:{
      166:  132:    const char* pch = string;
        -:  133:
      166:  134:    if (pch != NULL)
        -:  135:    {
     6020:  136:        while (*pch)
        -:  137:        {
        -:  138:#ifdef UNITY_OUTPUT_COLOR
        -:  139:            /* print ANSI escape code */
        -:  140:            if ((*pch == 27) && (*(pch + 1) == '['))
        -:  141:            {
        -:  142:                pch += UnityPrintAnsiEscapeString(pch);
        -:  143:                continue;
        -:  144:            }
        -:  145:#endif
     5854:  146:            UnityPrintChar(pch);
     5854:  147:            pch++;
        -:  148:        }
        -:  149:    }
      166:  150:}
        -:  151:/*-----------------------------------------------*/
    #####:  152:void UnityPrintLen(const char* string, const UNITY_UINT32 length)
        -:  153:{
    #####:  154:    const char* pch = string;
        -:  155:
    #####:  156:    if (pch != NULL)
        -:  157:    {
    #####:  158:        while (*pch && ((UNITY_UINT32)(pch - string) < length))
        -:  159:        {
        -:  160:            /* printable characters plus CR & LF are printed */
    #####:  161:            if ((*pch <= 126) && (*pch >= 32))
        -:  162:            {
    #####:  163:                UNITY_OUTPUT_CHAR(*pch);
        -:  164:            }
        -:  165:            /* write escaped carriage returns */
    #####:  166:            else if (*pch == 13)
        -:  167:            {
    #####:  168:                UNITY_OUTPUT_CHAR('\\');
    #####:  169:                UNITY_OUTPUT_CHAR('r');
        -:  170:            }
        -:  171:            /* write escaped line feeds */
    #####:  172:            else if (*pch == 10)
        -:  173:            {
    #####:  174:                UNITY_OUTPUT_CHAR('\\');
    #####:  175:                UNITY_OUTPUT_CHAR('n');
        -:  176:            }
        -:  177:            /* unprintable characters are shown as codes */
        -:  178:            else
        -:  179:            {
    #####:  180:                UNITY_OUTPUT_CHAR('\\');
    #####:  181:                UNITY_OUTPUT_CHAR('x');
    #####:  182:                UnityPrintNumberHex((UNITY_UINT)*pch, 2);
        -:  183:            }
    #####:  184:            pch++;
        -:  185:        }
        -:  186:    }
    #####:  187:}
        -:  188:
        -:  189:/*-----------------------------------------------*/
    #####:  190:void UnityPrintNumberByStyle(const UNITY_INT number, const UNITY_DISPLAY_STYLE_T style)
        -:  191:{
    #####:  192:    if ((style & UNITY_DISPLAY_RANGE_INT) == UNITY_DISPLAY_RANGE_INT)
        -:  193:    {
    #####:  194:        if (style == UNITY_DISPLAY_STYLE_CHAR)
        -:  195:        {
        -:  196:            /* printable characters plus CR & LF are printed */
    #####:  197:            UNITY_OUTPUT_CHAR('\'');
    #####:  198:            if ((number <= 126) && (number >= 32))
        -:  199:            {
    #####:  200:                UNITY_OUTPUT_CHAR((int)number);
        -:  201:            }
        -:  202:            /* write escaped carriage returns */
    #####:  203:            else if (number == 13)
        -:  204:            {
    #####:  205:                UNITY_OUTPUT_CHAR('\\');
    #####:  206:                UNITY_OUTPUT_CHAR('r');
        -:  207:            }
        -:  208:            /* write escaped line feeds */
    #####:  209:            else if (number == 10)
        -:  210:            {
    #####:  211:                UNITY_OUTPUT_CHAR('\\');
    #####:  212:                UNITY_OUTPUT_CHAR('n');
        -:  213:            }
        -:  214:            /* unprintable characters are shown as codes */
        -:  215:            else
        -:  216:            {
    #####:  217:                UNITY_OUTPUT_CHAR('\\');
    #####:  218:                UNITY_OUTPUT_CHAR('x');
    #####:  219:                UnityPrintNumberHex((UNITY_UINT)number, 2);
        -:  220:            }
    #####:  221:            UNITY_OUTPUT_CHAR('\'');
        -:  222:        }
        -:  223:        else
        -:  224:        {
    #####:  225:            UnityPrintNumber(number);
        -:  226:        }
        -:  227:    }
    #####:  228:    else if ((style & UNITY_DISPLAY_RANGE_UINT) == UNITY_DISPLAY_RANGE_UINT)
        -:  229:    {
    #####:  230:        UnityPrintNumberUnsigned((UNITY_UINT)number);
        -:  231:    }
        -:  232:    else
        -:  233:    {
    #####:  234:        UNITY_OUTPUT_CHAR('0');
    #####:  235:        UNITY_OUTPUT_CHAR('x');
    #####:  236:        UnityPrintNumberHex((UNITY_UINT)number, (char)((style & 0xF) * 2));
        -:  237:    }
    #####:  238:}
        -:  239:
        -:  240:/*-----------------------------------------------*/
       58:  241:void UnityPrintNumber(const UNITY_INT number_to_print)
        -:  242:{
       58:  243:    UNITY_UINT number = (UNITY_UINT)number_to_print;
        -:  244:
       58:  245:    if (number_to_print < 0)
        -:  246:    {
        -:  247:        /* A negative number, including MIN negative */
    #####:  248:        UNITY_OUTPUT_CHAR('-');
    #####:  249:        number = (~number) + 1;
        -:  250:    }
       58:  251:    UnityPrintNumberUnsigned(number);
       58:  252:}
        -:  253:
        -:  254:/*-----------------------------------------------
        -:  255: * basically do an itoa using as little ram as possible */
       58:  256:void UnityPrintNumberUnsigned(const UNITY_UINT number)
        -:  257:{
       58:  258:    UNITY_UINT divisor = 1;
        -:  259:
        -:  260:    /* figure out initial divisor */
      164:  261:    while (number / divisor > 9)
        -:  262:    {
      106:  263:        divisor *= 10;
        -:  264:    }
        -:  265:
        -:  266:    /* now mod and print, then divide divisor */
        -:  267:    do
        -:  268:    {
      164:  269:        UNITY_OUTPUT_CHAR((char)('0' + (number / divisor % 10)));
      164:  270:        divisor /= 10;
      164:  271:    } while (divisor > 0);
       58:  272:}
        -:  273:
        -:  274:/*-----------------------------------------------*/
    #####:  275:void UnityPrintNumberHex(const UNITY_UINT number, const char nibbles_to_print)
        -:  276:{
        -:  277:    int nibble;
    #####:  278:    char nibbles = nibbles_to_print;
        -:  279:
    #####:  280:    if ((unsigned)nibbles > UNITY_MAX_NIBBLES)
        -:  281:    {
    #####:  282:        nibbles = UNITY_MAX_NIBBLES;
        -:  283:    }
        -:  284:
    #####:  285:    while (nibbles > 0)
        -:  286:    {
    #####:  287:        nibbles--;
    #####:  288:        nibble = (int)(number >> (nibbles * 4)) & 0x0F;
    #####:  289:        if (nibble <= 9)
        -:  290:        {
    #####:  291:            UNITY_OUTPUT_CHAR((char)('0' + nibble));
        -:  292:        }
        -:  293:        else
        -:  294:        {
    #####:  295:            UNITY_OUTPUT_CHAR((char)('A' - 10 + nibble));
        -:  296:        }
        -:  297:    }
    #####:  298:}
        -:  299:
        -:  300:/*-----------------------------------------------*/
    #####:  301:void UnityPrintMask(const UNITY_UINT mask, const UNITY_UINT number)
        -:  302:{
    #####:  303:    UNITY_UINT current_bit = (UNITY_UINT)1 << (UNITY_INT_WIDTH - 1);
        -:  304:    UNITY_INT32 i;
        -:  305:
    #####:  306:    for (i = 0; i < UNITY_INT_WIDTH; i++)
        -:  307:    {
    #####:  308:        if (current_bit & mask)
        -:  309:        {
    #####:  310:            if (current_bit & number)
        -:  311:            {
    #####:  312:                UNITY_OUTPUT_CHAR('1');
        -:  313:            }
        -:  314:            else
        -:  315:            {
    #####:  316:                UNITY_OUTPUT_CHAR('0');
        -:  317:            }
        -:  318:        }
        -:  319:        else
        -:  320:        {
    #####:  321:            UNITY_OUTPUT_CHAR('X');
        -:  322:        }
    #####:  323:        current_bit = current_bit >> 1;
        -:  324:    }
    #####:  325:}
        -:  326:
        -:  327:/*-----------------------------------------------*/
        -:  328:#ifndef UNITY_EXCLUDE_FLOAT_PRINT
        -:  329:/*
        -:  330: * This function prints a floating-point value in a format similar to
        -:  331: * printf("%.7g") on a single-precision machine or printf("%.9g") on a
        -:  332: * double-precision machine.  The 7th digit won't always be totally correct
        -:  333: * in single-precision operation (for that level of accuracy, a more
        -:  334: * complicated algorithm would be needed).
        -:  335: */
    #####:  336:void UnityPrintFloat(const UNITY_DOUBLE input_number)
        -:  337:{
        -:  338:#ifdef UNITY_INCLUDE_DOUBLE
        -:  339:    static const int sig_digits = 9;
        -:  340:    static const UNITY_INT32 min_scaled = 100000000;
        -:  341:    static const UNITY_INT32 max_scaled = 1000000000;
        -:  342:#else
        -:  343:    static const int sig_digits = 7;
        -:  344:    static const UNITY_INT32 min_scaled = 1000000;
        -:  345:    static const UNITY_INT32 max_scaled = 10000000;
        -:  346:#endif
        -:  347:
    #####:  348:    UNITY_DOUBLE number = input_number;
        -:  349:
        -:  350:    /* print minus sign (does not handle negative zero) */
    #####:  351:    if (number < 0.0f)
        -:  352:    {
    #####:  353:        UNITY_OUTPUT_CHAR('-');
    #####:  354:        number = -number;
        -:  355:    }
        -:  356:
        -:  357:    /* handle zero, NaN, and +/- infinity */
    #####:  358:    if (number == 0.0f)
        -:  359:    {
    #####:  360:        UnityPrint("0");
        -:  361:    }
    #####:  362:    else if (isnan(number))
        -:  363:    {
    #####:  364:        UnityPrint("nan");
        -:  365:    }
    #####:  366:    else if (isinf(number))
        -:  367:    {
    #####:  368:        UnityPrint("inf");
        -:  369:    }
        -:  370:    else
        -:  371:    {
    #####:  372:        UNITY_INT32 n_int = 0, n;
    #####:  373:        int exponent = 0;
        -:  374:        int decimals, digits;
    #####:  375:        char buf[16] = {0};
        -:  376:
        -:  377:        /*
        -:  378:         * Scale up or down by powers of 10.  To minimize rounding error,
        -:  379:         * start with a factor/divisor of 10^10, which is the largest
        -:  380:         * power of 10 that can be represented exactly.  Finally, compute
        -:  381:         * (exactly) the remaining power of 10 and perform one more
        -:  382:         * multiplication or division.
        -:  383:         */
    #####:  384:        if (number < 1.0f)
        -:  385:        {
    #####:  386:            UNITY_DOUBLE factor = 1.0f;
        -:  387:
    #####:  388:            while (number < (UNITY_DOUBLE)max_scaled / 1e10f)  { number *= 1e10f; exponent -= 10; }
    #####:  389:            while (number * factor < (UNITY_DOUBLE)min_scaled) { factor *= 10.0f; exponent--; }
        -:  390:
    #####:  391:            number *= factor;
        -:  392:        }
    #####:  393:        else if (number > (UNITY_DOUBLE)max_scaled)
        -:  394:        {
    #####:  395:            UNITY_DOUBLE divisor = 1.0f;
        -:  396:
    #####:  397:            while (number > (UNITY_DOUBLE)min_scaled * 1e10f)   { number  /= 1e10f; exponent += 10; }
    #####:  398:            while (number / divisor > (UNITY_DOUBLE)max_scaled) { divisor *= 10.0f; exponent++; }
        -:  399:
    #####:  400:            number /= divisor;
        -:  401:        }
        -:  402:        else
        -:  403:        {
        -:  404:            /*
        -:  405:             * In this range, we can split off the integer part before
        -:  406:             * doing any multiplications.  This reduces rounding error by
        -:  407:             * freeing up significant bits in the fractional part.
        -:  408:             */
    #####:  409:            UNITY_DOUBLE factor = 1.0f;
    #####:  410:            n_int = (UNITY_INT32)number;
    #####:  411:            number -= (UNITY_DOUBLE)n_int;
        -:  412:
    #####:  413:            while (n_int < min_scaled) { n_int *= 10; factor *= 10.0f; exponent--; }
        -:  414:
    #####:  415:            number *= factor;
        -:  416:        }
        -:  417:
        -:  418:        /* round to nearest integer */
    #####:  419:        n = ((UNITY_INT32)(number + number) + 1) / 2;
        -:  420:
        -:  421:#ifndef UNITY_ROUND_TIES_AWAY_FROM_ZERO
        -:  422:        /* round to even if exactly between two integers */
    #####:  423:        if ((n & 1) && (((UNITY_DOUBLE)n - number) == 0.5f))
    #####:  424:            n--;
        -:  425:#endif
        -:  426:
    #####:  427:        n += n_int;
        -:  428:
    #####:  429:        if (n >= max_scaled)
        -:  430:        {
    #####:  431:            n = min_scaled;
    #####:  432:            exponent++;
        -:  433:        }
        -:  434:
        -:  435:        /* determine where to place decimal point */
    #####:  436:        decimals = ((exponent <= 0) && (exponent >= -(sig_digits + 3))) ? (-exponent) : (sig_digits - 1);
    #####:  437:        exponent += decimals;
        -:  438:
        -:  439:        /* truncate trailing zeroes after decimal point */
    #####:  440:        while ((decimals > 0) && ((n % 10) == 0))
        -:  441:        {
    #####:  442:            n /= 10;
    #####:  443:            decimals--;
        -:  444:        }
        -:  445:
        -:  446:        /* build up buffer in reverse order */
    #####:  447:        digits = 0;
    #####:  448:        while ((n != 0) || (digits < (decimals + 1)))
        -:  449:        {
    #####:  450:            buf[digits++] = (char)('0' + n % 10);
    #####:  451:            n /= 10;
        -:  452:        }
    #####:  453:        while (digits > 0)
        -:  454:        {
    #####:  455:            if (digits == decimals) { UNITY_OUTPUT_CHAR('.'); }
    #####:  456:            UNITY_OUTPUT_CHAR(buf[--digits]);
        -:  457:        }
        -:  458:
        -:  459:        /* print exponent if needed */
    #####:  460:        if (exponent != 0)
        -:  461:        {
    #####:  462:            UNITY_OUTPUT_CHAR('e');
        -:  463:
    #####:  464:            if (exponent < 0)
        -:  465:            {
    #####:  466:                UNITY_OUTPUT_CHAR('-');
    #####:  467:                exponent = -exponent;
        -:  468:            }
        -:  469:            else
        -:  470:            {
    #####:  471:                UNITY_OUTPUT_CHAR('+');
        -:  472:            }
        -:  473:
    #####:  474:            digits = 0;
    #####:  475:            while ((exponent != 0) || (digits < 2))
        -:  476:            {
    #####:  477:                buf[digits++] = (char)('0' + exponent % 10);
    #####:  478:                exponent /= 10;
        -:  479:            }
    #####:  480:            while (digits > 0)
        -:  481:            {
    #####:  482:                UNITY_OUTPUT_CHAR(buf[--digits]);
        -:  483:            }
        -:  484:        }
        -:  485:    }
    #####:  486:}
        -:  487:#endif /* ! UNITY_EXCLUDE_FLOAT_PRINT */
        -:  488:
        -:  489:/*-----------------------------------------------*/
       52:  490:static void UnityTestResultsBegin(const char* file, const UNITY_LINE_TYPE line)
        -:  491:{
        -:  492:#ifdef UNITY_OUTPUT_FOR_ECLIPSE
        -:  493:    UNITY_OUTPUT_CHAR('(');
        -:  494:    UnityPrint(file);
        -:  495:    UNITY_OUTPUT_CHAR(':');
        -:  496:    UnityPrintNumber((UNITY_INT)line);
        -:  497:    UNITY_OUTPUT_CHAR(')');
        -:  498:    UNITY_OUTPUT_CHAR(' ');
        -:  499:    UnityPrint(Unity.CurrentTestName);
        -:  500:    UNITY_OUTPUT_CHAR(':');
        -:  501:#else
        -:  502:#ifdef UNITY_OUTPUT_FOR_IAR_WORKBENCH
        -:  503:    UnityPrint("<SRCREF line=");
        -:  504:    UnityPrintNumber((UNITY_INT)line);
        -:  505:    UnityPrint(" file=\"");
        -:  506:    UnityPrint(file);
        -:  507:    UNITY_OUTPUT_CHAR('"');
        -:  508:    UNITY_OUTPUT_CHAR('>');
        -:  509:    UnityPrint(Unity.CurrentTestName);
        -:  510:    UnityPrint("</SRCREF> ");
        -:  511:#else
        -:  512:#ifdef UNITY_OUTPUT_FOR_QT_CREATOR
        -:  513:    UnityPrint("file://");
        -:  514:    UnityPrint(file);
        -:  515:    UNITY_OUTPUT_CHAR(':');
        -:  516:    UnityPrintNumber((UNITY_INT)line);
        -:  517:    UNITY_OUTPUT_CHAR(' ');
        -:  518:    UnityPrint(Unity.CurrentTestName);
        -:  519:    UNITY_OUTPUT_CHAR(':');
        -:  520:#else
       52:  521:    UnityPrint(file);
       52:  522:    UNITY_OUTPUT_CHAR(':');
       52:  523:    UnityPrintNumber((UNITY_INT)line);
       52:  524:    UNITY_OUTPUT_CHAR(':');
       52:  525:    UnityPrint(Unity.CurrentTestName);
       52:  526:    UNITY_OUTPUT_CHAR(':');
        -:  527:#endif
        -:  528:#endif
        -:  529:#endif
       52:  530:}
        -:  531:
        -:  532:/*-----------------------------------------------*/
    #####:  533:static void UnityTestResultsFailBegin(const UNITY_LINE_TYPE line)
        -:  534:{
    #####:  535:    UnityTestResultsBegin(Unity.TestFile, line);
    #####:  536:    UnityPrint(UnityStrFail);
    #####:  537:    UNITY_OUTPUT_CHAR(':');
    #####:  538:}
        -:  539:
        -:  540:/*-----------------------------------------------*/
       52:  541:void UnityConcludeTest(void)
        -:  542:{
       52:  543:    if (Unity.CurrentTestIgnored)
        -:  544:    {
    #####:  545:        Unity.TestIgnores++;
        -:  546:    }
       52:  547:    else if (!Unity.CurrentTestFailed)
        -:  548:    {
       52:  549:        UnityTestResultsBegin(Unity.TestFile, Unity.CurrentTestLineNumber);
       52:  550:        UnityPrint(UnityStrPass);
        -:  551:    }
        -:  552:    else
        -:  553:    {
    #####:  554:        Unity.TestFailures++;
        -:  555:    }
        -:  556:
       52:  557:    Unity.CurrentTestFailed = 0;
       52:  558:    Unity.CurrentTestIgnored = 0;
        -:  559:    UNITY_PRINT_EXEC_TIME();
       52:  560:    UNITY_PRINT_EOL();
        -:  561:    UNITY_FLUSH_CALL();
       52:  562:}
        -:  563:
        -:  564:/*-----------------------------------------------*/
    #####:  565:static void UnityAddMsgIfSpecified(const char* msg)
        -:  566:{
    #####:  567:    if (msg)
        -:  568:    {
    #####:  569:        UnityPrint(UnityStrSpacer);
        -:  570:
        -:  571:#ifdef UNITY_PRINT_TEST_CONTEXT
        -:  572:        UNITY_PRINT_TEST_CONTEXT();
        -:  573:#endif
        -:  574:#ifndef UNITY_EXCLUDE_DETAILS
    #####:  575:        if (Unity.CurrentDetail1)
        -:  576:        {
    #####:  577:            UnityPrint(UnityStrDetail1Name);
    #####:  578:            UnityPrint(Unity.CurrentDetail1);
    #####:  579:            if (Unity.CurrentDetail2)
        -:  580:            {
    #####:  581:                UnityPrint(UnityStrDetail2Name);
    #####:  582:                UnityPrint(Unity.CurrentDetail2);
        -:  583:            }
    #####:  584:            UnityPrint(UnityStrSpacer);
        -:  585:        }
        -:  586:#endif
    #####:  587:        UnityPrint(msg);
        -:  588:    }
    #####:  589:}
        -:  590:
        -:  591:/*-----------------------------------------------*/
    #####:  592:static void UnityPrintExpectedAndActualStrings(const char* expected, const char* actual)
        -:  593:{
    #####:  594:    UnityPrint(UnityStrExpected);
    #####:  595:    if (expected != NULL)
        -:  596:    {
    #####:  597:        UNITY_OUTPUT_CHAR('\'');
    #####:  598:        UnityPrint(expected);
    #####:  599:        UNITY_OUTPUT_CHAR('\'');
        -:  600:    }
        -:  601:    else
        -:  602:    {
    #####:  603:        UnityPrint(UnityStrNull);
        -:  604:    }
    #####:  605:    UnityPrint(UnityStrWas);
    #####:  606:    if (actual != NULL)
        -:  607:    {
    #####:  608:        UNITY_OUTPUT_CHAR('\'');
    #####:  609:        UnityPrint(actual);
    #####:  610:        UNITY_OUTPUT_CHAR('\'');
        -:  611:    }
        -:  612:    else
        -:  613:    {
    #####:  614:        UnityPrint(UnityStrNull);
        -:  615:    }
    #####:  616:}
        -:  617:
        -:  618:/*-----------------------------------------------*/
    #####:  619:static void UnityPrintExpectedAndActualStringsLen(const char* expected,
        -:  620:                                                  const char* actual,
        -:  621:                                                  const UNITY_UINT32 length)
        -:  622:{
    #####:  623:    UnityPrint(UnityStrExpected);
    #####:  624:    if (expected != NULL)
        -:  625:    {
    #####:  626:        UNITY_OUTPUT_CHAR('\'');
    #####:  627:        UnityPrintLen(expected, length);
    #####:  628:        UNITY_OUTPUT_CHAR('\'');
        -:  629:    }
        -:  630:    else
        -:  631:    {
    #####:  632:        UnityPrint(UnityStrNull);
        -:  633:    }
    #####:  634:    UnityPrint(UnityStrWas);
    #####:  635:    if (actual != NULL)
        -:  636:    {
    #####:  637:        UNITY_OUTPUT_CHAR('\'');
    #####:  638:        UnityPrintLen(actual, length);
    #####:  639:        UNITY_OUTPUT_CHAR('\'');
        -:  640:    }
        -:  641:    else
        -:  642:    {
    #####:  643:        UnityPrint(UnityStrNull);
        -:  644:    }
    #####:  645:}
        -:  646:
        -:  647:/*-----------------------------------------------
        -:  648: * Assertion & Control Helpers
        -:  649: *-----------------------------------------------*/
        -:  650:
        -:  651:/*-----------------------------------------------*/
    #####:  652:static int UnityIsOneArrayNull(UNITY_INTERNAL_PTR expected,
        -:  653:                               UNITY_INTERNAL_PTR actual,
        -:  654:                               const UNITY_LINE_TYPE lineNumber,
        -:  655:                               const char* msg)
        -:  656:{
        -:  657:    /* Both are NULL or same pointer */
    #####:  658:    if (expected == actual) { return 0; }
        -:  659:
        -:  660:    /* print and return true if just expected is NULL */
    #####:  661:    if (expected == NULL)
        -:  662:    {
    #####:  663:        UnityTestResultsFailBegin(lineNumber);
    #####:  664:        UnityPrint(UnityStrNullPointerForExpected);
    #####:  665:        UnityAddMsgIfSpecified(msg);
    #####:  666:        return 1;
        -:  667:    }
        -:  668:
        -:  669:    /* print and return true if just actual is NULL */
    #####:  670:    if (actual == NULL)
        -:  671:    {
    #####:  672:        UnityTestResultsFailBegin(lineNumber);
    #####:  673:        UnityPrint(UnityStrNullPointerForActual);
    #####:  674:        UnityAddMsgIfSpecified(msg);
    #####:  675:        return 1;
        -:  676:    }
        -:  677:
    #####:  678:    return 0; /* return false if neither is NULL */
        -:  679:}
        -:  680:
        -:  681:/*-----------------------------------------------
        -:  682: * Assertion Functions
        -:  683: *-----------------------------------------------*/
        -:  684:
        -:  685:/*-----------------------------------------------*/
    #####:  686:void UnityAssertBits(const UNITY_INT mask,
        -:  687:                     const UNITY_INT expected,
        -:  688:                     const UNITY_INT actual,
        -:  689:                     const char* msg,
        -:  690:                     const UNITY_LINE_TYPE lineNumber)
        -:  691:{
    #####:  692:    RETURN_IF_FAIL_OR_IGNORE;
        -:  693:
    #####:  694:    if ((mask & expected) != (mask & actual))
        -:  695:    {
    #####:  696:        UnityTestResultsFailBegin(lineNumber);
    #####:  697:        UnityPrint(UnityStrExpected);
    #####:  698:        UnityPrintMask((UNITY_UINT)mask, (UNITY_UINT)expected);
    #####:  699:        UnityPrint(UnityStrWas);
    #####:  700:        UnityPrintMask((UNITY_UINT)mask, (UNITY_UINT)actual);
    #####:  701:        UnityAddMsgIfSpecified(msg);
    #####:  702:        UNITY_FAIL_AND_BAIL;
        -:  703:    }
    #####:  704:}
        -:  705:
        -:  706:/*-----------------------------------------------*/
       38:  707:void UnityAssertEqualNumber(const UNITY_INT expected,
        -:  708:                            const UNITY_INT actual,
        -:  709:                            const char* msg,
        -:  710:                            const UNITY_LINE_TYPE lineNumber,
        -:  711:                            const UNITY_DISPLAY_STYLE_T style)
        -:  712:{
      38*:  713:    RETURN_IF_FAIL_OR_IGNORE;
        -:  714:
       38:  715:    if (expected != actual)
        -:  716:    {
    #####:  717:        UnityTestResultsFailBegin(lineNumber);
    #####:  718:        UnityPrint(UnityStrExpected);
    #####:  719:        UnityPrintNumberByStyle(expected, style);
    #####:  720:        UnityPrint(UnityStrWas);
    #####:  721:        UnityPrintNumberByStyle(actual, style);
    #####:  722:        UnityAddMsgIfSpecified(msg);
    #####:  723:        UNITY_FAIL_AND_BAIL;
        -:  724:    }
       38:  725:}
        -:  726:
        -:  727:/*-----------------------------------------------*/
    #####:  728:void UnityAssertGreaterOrLessOrEqualNumber(const UNITY_INT threshold,
        -:  729:                                           const UNITY_INT actual,
        -:  730:                                           const UNITY_COMPARISON_T compare,
        -:  731:                                           const char *msg,
        -:  732:                                           const UNITY_LINE_TYPE lineNumber,
        -:  733:                                           const UNITY_DISPLAY_STYLE_T style)
        -:  734:{
    #####:  735:    int failed = 0;
    #####:  736:    RETURN_IF_FAIL_OR_IGNORE;
        -:  737:
    #####:  738:    if ((threshold == actual) && (compare & UNITY_EQUAL_TO)) { return; }
    #####:  739:    if ((threshold == actual))                               { failed = 1; }
        -:  740:
    #####:  741:    if ((style & UNITY_DISPLAY_RANGE_INT) == UNITY_DISPLAY_RANGE_INT)
        -:  742:    {
    #####:  743:        if ((actual > threshold) && (compare & UNITY_SMALLER_THAN)) { failed = 1; }
    #####:  744:        if ((actual < threshold) && (compare & UNITY_GREATER_THAN)) { failed = 1; }
        -:  745:    }
        -:  746:    else /* UINT or HEX */
        -:  747:    {
    #####:  748:        if (((UNITY_UINT)actual > (UNITY_UINT)threshold) && (compare & UNITY_SMALLER_THAN)) { failed = 1; }
    #####:  749:        if (((UNITY_UINT)actual < (UNITY_UINT)threshold) && (compare & UNITY_GREATER_THAN)) { failed = 1; }
        -:  750:    }
        -:  751:
    #####:  752:    if (failed)
        -:  753:    {
    #####:  754:        UnityTestResultsFailBegin(lineNumber);
    #####:  755:        UnityPrint(UnityStrExpected);
    #####:  756:        UnityPrintNumberByStyle(actual, style);
    #####:  757:        if (compare & UNITY_GREATER_THAN) { UnityPrint(UnityStrGt);       }
    #####:  758:        if (compare & UNITY_SMALLER_THAN) { UnityPrint(UnityStrLt);       }
    #####:  759:        if (compare & UNITY_EQUAL_TO)     { UnityPrint(UnityStrOrEqual);  }
    #####:  760:        if (compare == UNITY_NOT_EQUAL)   { UnityPrint(UnityStrNotEqual); }
    #####:  761:        UnityPrintNumberByStyle(threshold, style);
    #####:  762:        UnityAddMsgIfSpecified(msg);
    #####:  763:        UNITY_FAIL_AND_BAIL;
        -:  764:    }
        -:  765:}
        -:  766:
        -:  767:#define UnityPrintPointlessAndBail()       \
        -:  768:{                                          \
        -:  769:    UnityTestResultsFailBegin(lineNumber); \
        -:  770:    UnityPrint(UnityStrPointless);         \
        -:  771:    UnityAddMsgIfSpecified(msg);           \
        -:  772:    UNITY_FAIL_AND_BAIL; }
        -:  773:
        -:  774:/*-----------------------------------------------*/
    #####:  775:void UnityAssertEqualIntArray(UNITY_INTERNAL_PTR expected,
        -:  776:                              UNITY_INTERNAL_PTR actual,
        -:  777:                              const UNITY_UINT32 num_elements,
        -:  778:                              const char* msg,
        -:  779:                              const UNITY_LINE_TYPE lineNumber,
        -:  780:                              const UNITY_DISPLAY_STYLE_T style,
        -:  781:                              const UNITY_FLAGS_T flags)
        -:  782:{
    #####:  783:    UNITY_UINT32 elements  = num_elements;
    #####:  784:    unsigned int length    = style & 0xF;
    #####:  785:    unsigned int increment = 0;
        -:  786:
    #####:  787:    RETURN_IF_FAIL_OR_IGNORE;
        -:  788:
    #####:  789:    if (num_elements == 0)
        -:  790:    {
    #####:  791:        UnityPrintPointlessAndBail();
        -:  792:    }
        -:  793:
    #####:  794:    if (expected == actual)
        -:  795:    {
    #####:  796:        return; /* Both are NULL or same pointer */
        -:  797:    }
        -:  798:
    #####:  799:    if (UnityIsOneArrayNull(expected, actual, lineNumber, msg))
        -:  800:    {
    #####:  801:        UNITY_FAIL_AND_BAIL;
        -:  802:    }
        -:  803:
    #####:  804:    while ((elements > 0) && (elements--))
        -:  805:    {
        -:  806:        UNITY_INT expect_val;
        -:  807:        UNITY_INT actual_val;
        -:  808:
    #####:  809:        switch (length)
        -:  810:        {
    #####:  811:            case 1:
    #####:  812:                expect_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT8*)expected;
    #####:  813:                actual_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT8*)actual;
    #####:  814:                increment  = sizeof(UNITY_INT8);
    #####:  815:                break;
        -:  816:
    #####:  817:            case 2:
    #####:  818:                expect_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT16*)expected;
    #####:  819:                actual_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT16*)actual;
    #####:  820:                increment  = sizeof(UNITY_INT16);
    #####:  821:                break;
        -:  822:
        -:  823:#ifdef UNITY_SUPPORT_64
    #####:  824:            case 8:
    #####:  825:                expect_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT64*)expected;
    #####:  826:                actual_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT64*)actual;
    #####:  827:                increment  = sizeof(UNITY_INT64);
    #####:  828:                break;
        -:  829:#endif
        -:  830:
    #####:  831:            default: /* default is length 4 bytes */
        -:  832:            case 4:
    #####:  833:                expect_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT32*)expected;
    #####:  834:                actual_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT32*)actual;
    #####:  835:                increment  = sizeof(UNITY_INT32);
    #####:  836:                length = 4;
    #####:  837:                break;
        -:  838:        }
        -:  839:
    #####:  840:        if (expect_val != actual_val)
        -:  841:        {
    #####:  842:            if ((style & UNITY_DISPLAY_RANGE_UINT) && (length < (UNITY_INT_WIDTH / 8)))
        -:  843:            {   /* For UINT, remove sign extension (padding 1's) from signed type casts above */
    #####:  844:                UNITY_INT mask = 1;
    #####:  845:                mask = (mask << 8 * length) - 1;
    #####:  846:                expect_val &= mask;
    #####:  847:                actual_val &= mask;
        -:  848:            }
    #####:  849:            UnityTestResultsFailBegin(lineNumber);
    #####:  850:            UnityPrint(UnityStrElement);
    #####:  851:            UnityPrintNumberUnsigned(num_elements - elements - 1);
    #####:  852:            UnityPrint(UnityStrExpected);
    #####:  853:            UnityPrintNumberByStyle(expect_val, style);
    #####:  854:            UnityPrint(UnityStrWas);
    #####:  855:            UnityPrintNumberByStyle(actual_val, style);
    #####:  856:            UnityAddMsgIfSpecified(msg);
    #####:  857:            UNITY_FAIL_AND_BAIL;
        -:  858:        }
        -:  859:        /* Walk through array by incrementing the pointers */
    #####:  860:        if (flags == UNITY_ARRAY_TO_ARRAY)
        -:  861:        {
    #####:  862:            expected = (UNITY_INTERNAL_PTR)((const char*)expected + increment);
        -:  863:        }
    #####:  864:        actual = (UNITY_INTERNAL_PTR)((const char*)actual + increment);
        -:  865:    }
        -:  866:}
        -:  867:
        -:  868:/*-----------------------------------------------*/
        -:  869:#ifndef UNITY_EXCLUDE_FLOAT
        -:  870:/* Wrap this define in a function with variable types as float or double */
        -:  871:#define UNITY_FLOAT_OR_DOUBLE_WITHIN(delta, expected, actual, diff)                           \
        -:  872:    if (isinf(expected) && isinf(actual) && (((expected) < 0) == ((actual) < 0))) return 1;   \
        -:  873:    if (UNITY_NAN_CHECK) return 1;                                                            \
        -:  874:    (diff) = (actual) - (expected);                                                           \
        -:  875:    if ((diff) < 0) (diff) = -(diff);                                                         \
        -:  876:    if ((delta) < 0) (delta) = -(delta);                                                      \
        -:  877:    return !(isnan(diff) || isinf(diff) || ((diff) > (delta)))
        -:  878:    /* This first part of this condition will catch any NaN or Infinite values */
        -:  879:#ifndef UNITY_NAN_NOT_EQUAL_NAN
        -:  880:  #define UNITY_NAN_CHECK isnan(expected) && isnan(actual)
        -:  881:#else
        -:  882:  #define UNITY_NAN_CHECK 0
        -:  883:#endif
        -:  884:
        -:  885:#ifndef UNITY_EXCLUDE_FLOAT_PRINT
        -:  886:  #define UNITY_PRINT_EXPECTED_AND_ACTUAL_FLOAT(expected, actual) \
        -:  887:  {                                                               \
        -:  888:    UnityPrint(UnityStrExpected);                                 \
        -:  889:    UnityPrintFloat(expected);                                    \
        -:  890:    UnityPrint(UnityStrWas);                                      \
        -:  891:    UnityPrintFloat(actual); }
        -:  892:#else
        -:  893:  #define UNITY_PRINT_EXPECTED_AND_ACTUAL_FLOAT(expected, actual) \
        -:  894:    UnityPrint(UnityStrDelta)
        -:  895:#endif /* UNITY_EXCLUDE_FLOAT_PRINT */
        -:  896:
        -:  897:/*-----------------------------------------------*/
    #####:  898:static int UnityFloatsWithin(UNITY_FLOAT delta, UNITY_FLOAT expected, UNITY_FLOAT actual)
        -:  899:{
        -:  900:    UNITY_FLOAT diff;
    #####:  901:    UNITY_FLOAT_OR_DOUBLE_WITHIN(delta, expected, actual, diff);
        -:  902:}
        -:  903:
        -:  904:/*-----------------------------------------------*/
    #####:  905:void UnityAssertEqualFloatArray(UNITY_PTR_ATTRIBUTE const UNITY_FLOAT* expected,
        -:  906:                                UNITY_PTR_ATTRIBUTE const UNITY_FLOAT* actual,
        -:  907:                                const UNITY_UINT32 num_elements,
        -:  908:                                const char* msg,
        -:  909:                                const UNITY_LINE_TYPE lineNumber,
        -:  910:                                const UNITY_FLAGS_T flags)
        -:  911:{
    #####:  912:    UNITY_UINT32 elements = num_elements;
    #####:  913:    UNITY_PTR_ATTRIBUTE const UNITY_FLOAT* ptr_expected = expected;
    #####:  914:    UNITY_PTR_ATTRIBUTE const UNITY_FLOAT* ptr_actual = actual;
        -:  915:
    #####:  916:    RETURN_IF_FAIL_OR_IGNORE;
        -:  917:
    #####:  918:    if (elements == 0)
        -:  919:    {
    #####:  920:        UnityPrintPointlessAndBail();
        -:  921:    }
        -:  922:
    #####:  923:    if (expected == actual)
        -:  924:    {
    #####:  925:        return; /* Both are NULL or same pointer */
        -:  926:    }
        -:  927:
    #####:  928:    if (UnityIsOneArrayNull((UNITY_INTERNAL_PTR)expected, (UNITY_INTERNAL_PTR)actual, lineNumber, msg))
        -:  929:    {
    #####:  930:        UNITY_FAIL_AND_BAIL;
        -:  931:    }
        -:  932:
    #####:  933:    while (elements--)
        -:  934:    {
    #####:  935:        if (!UnityFloatsWithin(*ptr_expected * UNITY_FLOAT_PRECISION, *ptr_expected, *ptr_actual))
        -:  936:        {
    #####:  937:            UnityTestResultsFailBegin(lineNumber);
    #####:  938:            UnityPrint(UnityStrElement);
    #####:  939:            UnityPrintNumberUnsigned(num_elements - elements - 1);
    #####:  940:            UNITY_PRINT_EXPECTED_AND_ACTUAL_FLOAT((UNITY_DOUBLE)*ptr_expected, (UNITY_DOUBLE)*ptr_actual);
    #####:  941:            UnityAddMsgIfSpecified(msg);
    #####:  942:            UNITY_FAIL_AND_BAIL;
        -:  943:        }
    #####:  944:        if (flags == UNITY_ARRAY_TO_ARRAY)
        -:  945:        {
    #####:  946:            ptr_expected++;
        -:  947:        }
    #####:  948:        ptr_actual++;
        -:  949:    }
        -:  950:}
        -:  951:
        -:  952:/*-----------------------------------------------*/
    #####:  953:void UnityAssertFloatsWithin(const UNITY_FLOAT delta,
        -:  954:                             const UNITY_FLOAT expected,
        -:  955:                             const UNITY_FLOAT actual,
        -:  956:                             const char* msg,
        -:  957:                             const UNITY_LINE_TYPE lineNumber)
        -:  958:{
    #####:  959:    RETURN_IF_FAIL_OR_IGNORE;
        -:  960:
        -:  961:
    #####:  962:    if (!UnityFloatsWithin(delta, expected, actual))
        -:  963:    {
    #####:  964:        UnityTestResultsFailBegin(lineNumber);
    #####:  965:        UNITY_PRINT_EXPECTED_AND_ACTUAL_FLOAT((UNITY_DOUBLE)expected, (UNITY_DOUBLE)actual);
    #####:  966:        UnityAddMsgIfSpecified(msg);
    #####:  967:        UNITY_FAIL_AND_BAIL;
        -:  968:    }
    #####:  969:}
        -:  970:
        -:  971:/*-----------------------------------------------*/
    #####:  972:void UnityAssertFloatSpecial(const UNITY_FLOAT actual,
        -:  973:                             const char* msg,
        -:  974:                             const UNITY_LINE_TYPE lineNumber,
        -:  975:                             const UNITY_FLOAT_TRAIT_T style)
        -:  976:{
    #####:  977:    const char* trait_names[] = {UnityStrInf, UnityStrNegInf, UnityStrNaN, UnityStrDet};
    #####:  978:    UNITY_INT should_be_trait = ((UNITY_INT)style & 1);
    #####:  979:    UNITY_INT is_trait        = !should_be_trait;
    #####:  980:    UNITY_INT trait_index     = (UNITY_INT)(style >> 1);
        -:  981:
    #####:  982:    RETURN_IF_FAIL_OR_IGNORE;
        -:  983:
    #####:  984:    switch (style)
        -:  985:    {
    #####:  986:        case UNITY_FLOAT_IS_INF:
        -:  987:        case UNITY_FLOAT_IS_NOT_INF:
    #####:  988:            is_trait = isinf(actual) && (actual > 0);
    #####:  989:            break;
    #####:  990:        case UNITY_FLOAT_IS_NEG_INF:
        -:  991:        case UNITY_FLOAT_IS_NOT_NEG_INF:
    #####:  992:            is_trait = isinf(actual) && (actual < 0);
    #####:  993:            break;
        -:  994:
    #####:  995:        case UNITY_FLOAT_IS_NAN:
        -:  996:        case UNITY_FLOAT_IS_NOT_NAN:
    #####:  997:            is_trait = isnan(actual) ? 1 : 0;
    #####:  998:            break;
        -:  999:
    #####: 1000:        case UNITY_FLOAT_IS_DET: /* A determinate number is non infinite and not NaN. */
        -: 1001:        case UNITY_FLOAT_IS_NOT_DET:
    #####: 1002:            is_trait = !isinf(actual) && !isnan(actual);
    #####: 1003:            break;
        -: 1004:
    #####: 1005:        default: /* including UNITY_FLOAT_INVALID_TRAIT */
    #####: 1006:            trait_index = 0;
    #####: 1007:            trait_names[0] = UnityStrInvalidFloatTrait;
    #####: 1008:            break;
        -: 1009:    }
        -: 1010:
    #####: 1011:    if (is_trait != should_be_trait)
        -: 1012:    {
    #####: 1013:        UnityTestResultsFailBegin(lineNumber);
    #####: 1014:        UnityPrint(UnityStrExpected);
    #####: 1015:        if (!should_be_trait)
        -: 1016:        {
    #####: 1017:            UnityPrint(UnityStrNot);
        -: 1018:        }
    #####: 1019:        UnityPrint(trait_names[trait_index]);
    #####: 1020:        UnityPrint(UnityStrWas);
        -: 1021:#ifndef UNITY_EXCLUDE_FLOAT_PRINT
    #####: 1022:        UnityPrintFloat((UNITY_DOUBLE)actual);
        -: 1023:#else
        -: 1024:        if (should_be_trait)
        -: 1025:        {
        -: 1026:            UnityPrint(UnityStrNot);
        -: 1027:        }
        -: 1028:        UnityPrint(trait_names[trait_index]);
        -: 1029:#endif
    #####: 1030:        UnityAddMsgIfSpecified(msg);
    #####: 1031:        UNITY_FAIL_AND_BAIL;
        -: 1032:    }
    #####: 1033:}
        -: 1034:
        -: 1035:#endif /* not UNITY_EXCLUDE_FLOAT */
        -: 1036:
        -: 1037:/*-----------------------------------------------*/
        -: 1038:#ifndef UNITY_EXCLUDE_DOUBLE
    #####: 1039:static int UnityDoublesWithin(UNITY_DOUBLE delta, UNITY_DOUBLE expected, UNITY_DOUBLE actual)
        -: 1040:{
        -: 1041:    UNITY_DOUBLE diff;
    #####: 1042:    UNITY_FLOAT_OR_DOUBLE_WITHIN(delta, expected, actual, diff);
        -: 1043:}
        -: 1044:
        -: 1045:/*-----------------------------------------------*/
    #####: 1046:void UnityAssertEqualDoubleArray(UNITY_PTR_ATTRIBUTE const UNITY_DOUBLE* expected,
        -: 1047:                                 UNITY_PTR_ATTRIBUTE const UNITY_DOUBLE* actual,
        -: 1048:                                 const UNITY_UINT32 num_elements,
        -: 1049:                                 const char* msg,
        -: 1050:                                 const UNITY_LINE_TYPE lineNumber,
        -: 1051:                                 const UNITY_FLAGS_T flags)
        -: 1052:{
    #####: 1053:    UNITY_UINT32 elements = num_elements;
    #####: 1054:    UNITY_PTR_ATTRIBUTE const UNITY_DOUBLE* ptr_expected = expected;
    #####: 1055:    UNITY_PTR_ATTRIBUTE const UNITY_DOUBLE* ptr_actual = actual;
        -: 1056:
    #####: 1057:    RETURN_IF_FAIL_OR_IGNORE;
        -: 1058:
    #####: 1059:    if (elements == 0)
        -: 1060:    {
    #####: 1061:        UnityPrintPointlessAndBail();
        -: 1062:    }
        -: 1063:
    #####: 1064:    if (expected == actual)
        -: 1065:    {
    #####: 1066:        return; /* Both are NULL or same pointer */
        -: 1067:    }
        -: 1068:
    #####: 1069:    if (UnityIsOneArrayNull((UNITY_INTERNAL_PTR)expected, (UNITY_INTERNAL_PTR)actual, lineNumber, msg))
        -: 1070:    {
    #####: 1071:        UNITY_FAIL_AND_BAIL;
        -: 1072:    }
        -: 1073:
    #####: 1074:    while (elements--)
        -: 1075:    {
    #####: 1076:        if (!UnityDoublesWithin(*ptr_expected * UNITY_DOUBLE_PRECISION, *ptr_expected, *ptr_actual))
        -: 1077:        {
    #####: 1078:            UnityTestResultsFailBegin(lineNumber);
    #####: 1079:            UnityPrint(UnityStrElement);
    #####: 1080:            UnityPrintNumberUnsigned(num_elements - elements - 1);
    #####: 1081:            UNITY_PRINT_EXPECTED_AND_ACTUAL_FLOAT(*ptr_expected, *ptr_actual);
    #####: 1082:            UnityAddMsgIfSpecified(msg);
    #####: 1083:            UNITY_FAIL_AND_BAIL;
        -: 1084:        }
    #####: 1085:        if (flags == UNITY_ARRAY_TO_ARRAY)
        -: 1086:        {
    #####: 1087:            ptr_expected++;
        -: 1088:        }
    #####: 1089:        ptr_actual++;
        -: 1090:    }
        -: 1091:}
        -: 1092:
        -: 1093:/*-----------------------------------------------*/
    #####: 1094:void UnityAssertDoublesWithin(const UNITY_DOUBLE delta,
        -: 1095:                              const UNITY_DOUBLE expected,
        -: 1096:                              const UNITY_DOUBLE actual,
        -: 1097:                              const char* msg,
        -: 1098:                              const UNITY_LINE_TYPE lineNumber)
        -: 1099:{
    #####: 1100:    RETURN_IF_FAIL_OR_IGNORE;
        -: 1101:
    #####: 1102:    if (!UnityDoublesWithin(delta, expected, actual))
        -: 1103:    {
    #####: 1104:        UnityTestResultsFailBegin(lineNumber);
    #####: 1105:        UNITY_PRINT_EXPECTED_AND_ACTUAL_FLOAT(expected, actual);
    #####: 1106:        UnityAddMsgIfSpecified(msg);
    #####: 1107:        UNITY_FAIL_AND_BAIL;
        -: 1108:    }
    #####: 1109:}
        -: 1110:
        -: 1111:/*-----------------------------------------------*/
    #####: 1112:void UnityAssertDoubleSpecial(const UNITY_DOUBLE actual,
        -: 1113:                              const char* msg,
        -: 1114:                              const UNITY_LINE_TYPE lineNumber,
        -: 1115:                              const UNITY_FLOAT_TRAIT_T style)
        -: 1116:{
    #####: 1117:    const char* trait_names[] = {UnityStrInf, UnityStrNegInf, UnityStrNaN, UnityStrDet};
    #####: 1118:    UNITY_INT should_be_trait = ((UNITY_INT)style & 1);
    #####: 1119:    UNITY_INT is_trait        = !should_be_trait;
    #####: 1120:    UNITY_INT trait_index     = (UNITY_INT)(style >> 1);
        -: 1121:
    #####: 1122:    RETURN_IF_FAIL_OR_IGNORE;
        -: 1123:
    #####: 1124:    switch (style)
        -: 1125:    {
    #####: 1126:        case UNITY_FLOAT_IS_INF:
        -: 1127:        case UNITY_FLOAT_IS_NOT_INF:
    #####: 1128:            is_trait = isinf(actual) && (actual > 0);
    #####: 1129:            break;
    #####: 1130:        case UNITY_FLOAT_IS_NEG_INF:
        -: 1131:        case UNITY_FLOAT_IS_NOT_NEG_INF:
    #####: 1132:            is_trait = isinf(actual) && (actual < 0);
    #####: 1133:            break;
        -: 1134:
    #####: 1135:        case UNITY_FLOAT_IS_NAN:
        -: 1136:        case UNITY_FLOAT_IS_NOT_NAN:
    #####: 1137:            is_trait = isnan(actual) ? 1 : 0;
    #####: 1138:            break;
        -: 1139:
    #####: 1140:        case UNITY_FLOAT_IS_DET: /* A determinate number is non infinite and not NaN. */
        -: 1141:        case UNITY_FLOAT_IS_NOT_DET:
    #####: 1142:            is_trait = !isinf(actual) && !isnan(actual);
    #####: 1143:            break;
        -: 1144:
    #####: 1145:        default: /* including UNITY_FLOAT_INVALID_TRAIT */
    #####: 1146:            trait_index = 0;
    #####: 1147:            trait_names[0] = UnityStrInvalidFloatTrait;
    #####: 1148:            break;
        -: 1149:    }
        -: 1150:
    #####: 1151:    if (is_trait != should_be_trait)
        -: 1152:    {
    #####: 1153:        UnityTestResultsFailBegin(lineNumber);
    #####: 1154:        UnityPrint(UnityStrExpected);
    #####: 1155:        if (!should_be_trait)
        -: 1156:        {
    #####: 1157:            UnityPrint(UnityStrNot);
        -: 1158:        }
    #####: 1159:        UnityPrint(trait_names[trait_index]);
    #####: 1160:        UnityPrint(UnityStrWas);
        -: 1161:#ifndef UNITY_EXCLUDE_FLOAT_PRINT
    #####: 1162:        UnityPrintFloat(actual);
        -: 1163:#else
        -: 1164:        if (should_be_trait)
        -: 1165:        {
        -: 1166:            UnityPrint(UnityStrNot);
        -: 1167:        }
        -: 1168:        UnityPrint(trait_names[trait_index]);
        -: 1169:#endif
    #####: 1170:        UnityAddMsgIfSpecified(msg);
    #####: 1171:        UNITY_FAIL_AND_BAIL;
        -: 1172:    }
    #####: 1173:}
        -: 1174:
        -: 1175:#endif /* not UNITY_EXCLUDE_DOUBLE */
        -: 1176:
        -: 1177:/*-----------------------------------------------*/
    #####: 1178:void UnityAssertNumbersWithin(const UNITY_UINT delta,
        -: 1179:                              const UNITY_INT expected,
        -: 1180:                              const UNITY_INT actual,
        -: 1181:                              const char* msg,
        -: 1182:                              const UNITY_LINE_TYPE lineNumber,
        -: 1183:                              const UNITY_DISPLAY_STYLE_T style)
        -: 1184:{
    #####: 1185:    RETURN_IF_FAIL_OR_IGNORE;
        -: 1186:
    #####: 1187:    if ((style & UNITY_DISPLAY_RANGE_INT) == UNITY_DISPLAY_RANGE_INT)
        -: 1188:    {
    #####: 1189:        if (actual > expected)
        -: 1190:        {
    #####: 1191:            Unity.CurrentTestFailed = (((UNITY_UINT)actual - (UNITY_UINT)expected) > delta);
        -: 1192:        }
        -: 1193:        else
        -: 1194:        {
    #####: 1195:            Unity.CurrentTestFailed = (((UNITY_UINT)expected - (UNITY_UINT)actual) > delta);
        -: 1196:        }
        -: 1197:    }
        -: 1198:    else
        -: 1199:    {
    #####: 1200:        if ((UNITY_UINT)actual > (UNITY_UINT)expected)
        -: 1201:        {
    #####: 1202:            Unity.CurrentTestFailed = (((UNITY_UINT)actual - (UNITY_UINT)expected) > delta);
        -: 1203:        }
        -: 1204:        else
        -: 1205:        {
    #####: 1206:            Unity.CurrentTestFailed = (((UNITY_UINT)expected - (UNITY_UINT)actual) > delta);
        -: 1207:        }
        -: 1208:    }
        -: 1209:
    #####: 1210:    if (Unity.CurrentTestFailed)
        -: 1211:    {
    #####: 1212:        UnityTestResultsFailBegin(lineNumber);
    #####: 1213:        UnityPrint(UnityStrDelta);
    #####: 1214:        UnityPrintNumberByStyle((UNITY_INT)delta, style);
    #####: 1215:        UnityPrint(UnityStrExpected);
    #####: 1216:        UnityPrintNumberByStyle(expected, style);
    #####: 1217:        UnityPrint(UnityStrWas);
    #####: 1218:        UnityPrintNumberByStyle(actual, style);
    #####: 1219:        UnityAddMsgIfSpecified(msg);
    #####: 1220:        UNITY_FAIL_AND_BAIL;
        -: 1221:    }
    #####: 1222:}
        -: 1223:
        -: 1224:/*-----------------------------------------------*/
    #####: 1225:void UnityAssertNumbersArrayWithin(const UNITY_UINT delta,
        -: 1226:                                   UNITY_INTERNAL_PTR expected,
        -: 1227:                                   UNITY_INTERNAL_PTR actual,
        -: 1228:                                   const UNITY_UINT32 num_elements,
        -: 1229:                                   const char* msg,
        -: 1230:                                   const UNITY_LINE_TYPE lineNumber,
        -: 1231:                                   const UNITY_DISPLAY_STYLE_T style,
        -: 1232:                                   const UNITY_FLAGS_T flags)
        -: 1233:{
    #####: 1234:    UNITY_UINT32 elements = num_elements;
    #####: 1235:    unsigned int length   = style & 0xF;
    #####: 1236:    unsigned int increment = 0;
        -: 1237:
    #####: 1238:    RETURN_IF_FAIL_OR_IGNORE;
        -: 1239:
    #####: 1240:    if (num_elements == 0)
        -: 1241:    {
    #####: 1242:        UnityPrintPointlessAndBail();
        -: 1243:    }
        -: 1244:
    #####: 1245:    if (expected == actual)
        -: 1246:    {
    #####: 1247:        return; /* Both are NULL or same pointer */
        -: 1248:    }
        -: 1249:
    #####: 1250:    if (UnityIsOneArrayNull(expected, actual, lineNumber, msg))
        -: 1251:    {
    #####: 1252:        UNITY_FAIL_AND_BAIL;
        -: 1253:    }
        -: 1254:
    #####: 1255:    while ((elements > 0) && (elements--))
        -: 1256:    {
        -: 1257:        UNITY_INT expect_val;
        -: 1258:        UNITY_INT actual_val;
        -: 1259:
    #####: 1260:        switch (length)
        -: 1261:        {
    #####: 1262:            case 1:
    #####: 1263:                expect_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT8*)expected;
    #####: 1264:                actual_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT8*)actual;
    #####: 1265:                increment  = sizeof(UNITY_INT8);
    #####: 1266:                break;
        -: 1267:
    #####: 1268:            case 2:
    #####: 1269:                expect_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT16*)expected;
    #####: 1270:                actual_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT16*)actual;
    #####: 1271:                increment  = sizeof(UNITY_INT16);
    #####: 1272:                break;
        -: 1273:
        -: 1274:#ifdef UNITY_SUPPORT_64
    #####: 1275:            case 8:
    #####: 1276:                expect_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT64*)expected;
    #####: 1277:                actual_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT64*)actual;
    #####: 1278:                increment  = sizeof(UNITY_INT64);
    #####: 1279:                break;
        -: 1280:#endif
        -: 1281:
    #####: 1282:            default: /* default is length 4 bytes */
        -: 1283:            case 4:
    #####: 1284:                expect_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT32*)expected;
    #####: 1285:                actual_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT32*)actual;
    #####: 1286:                increment  = sizeof(UNITY_INT32);
    #####: 1287:                length = 4;
    #####: 1288:                break;
        -: 1289:        }
        -: 1290:
    #####: 1291:        if ((style & UNITY_DISPLAY_RANGE_INT) == UNITY_DISPLAY_RANGE_INT)
        -: 1292:        {
    #####: 1293:            if (actual_val > expect_val)
        -: 1294:            {
    #####: 1295:                Unity.CurrentTestFailed = (((UNITY_UINT)actual_val - (UNITY_UINT)expect_val) > delta);
        -: 1296:            }
        -: 1297:            else
        -: 1298:            {
    #####: 1299:                Unity.CurrentTestFailed = (((UNITY_UINT)expect_val - (UNITY_UINT)actual_val) > delta);
        -: 1300:            }
        -: 1301:        }
        -: 1302:        else
        -: 1303:        {
    #####: 1304:            if ((UNITY_UINT)actual_val > (UNITY_UINT)expect_val)
        -: 1305:            {
    #####: 1306:                Unity.CurrentTestFailed = (((UNITY_UINT)actual_val - (UNITY_UINT)expect_val) > delta);
        -: 1307:            }
        -: 1308:            else
        -: 1309:            {
    #####: 1310:                Unity.CurrentTestFailed = (((UNITY_UINT)expect_val - (UNITY_UINT)actual_val) > delta);
        -: 1311:            }
        -: 1312:        }
        -: 1313:
    #####: 1314:        if (Unity.CurrentTestFailed)
        -: 1315:        {
    #####: 1316:            if ((style & UNITY_DISPLAY_RANGE_UINT) && (length < (UNITY_INT_WIDTH / 8)))
        -: 1317:            {   /* For UINT, remove sign extension (padding 1's) from signed type casts above */
    #####: 1318:                UNITY_INT mask = 1;
    #####: 1319:                mask = (mask << 8 * length) - 1;
    #####: 1320:                expect_val &= mask;
    #####: 1321:                actual_val &= mask;
        -: 1322:            }
    #####: 1323:            UnityTestResultsFailBegin(lineNumber);
    #####: 1324:            UnityPrint(UnityStrDelta);
    #####: 1325:            UnityPrintNumberByStyle((UNITY_INT)delta, style);
    #####: 1326:            UnityPrint(UnityStrElement);
    #####: 1327:            UnityPrintNumberUnsigned(num_elements - elements - 1);
    #####: 1328:            UnityPrint(UnityStrExpected);
    #####: 1329:            UnityPrintNumberByStyle(expect_val, style);
    #####: 1330:            UnityPrint(UnityStrWas);
    #####: 1331:            UnityPrintNumberByStyle(actual_val, style);
    #####: 1332:            UnityAddMsgIfSpecified(msg);
    #####: 1333:            UNITY_FAIL_AND_BAIL;
        -: 1334:        }
        -: 1335:        /* Walk through array by incrementing the pointers */
    #####: 1336:        if (flags == UNITY_ARRAY_TO_ARRAY)
        -: 1337:        {
    #####: 1338:            expected = (UNITY_INTERNAL_PTR)((const char*)expected + increment);
        -: 1339:        }
    #####: 1340:        actual = (UNITY_INTERNAL_PTR)((const char*)actual + increment);
        -: 1341:    }
        -: 1342:}
        -: 1343:
        -: 1344:/*-----------------------------------------------*/
       34: 1345:void UnityAssertEqualString(const char* expected,
        -: 1346:                            const char* actual,
        -: 1347:                            const char* msg,
        -: 1348:                            const UNITY_LINE_TYPE lineNumber)
        -: 1349:{
        -: 1350:    UNITY_UINT32 i;
        -: 1351:
      34*: 1352:    RETURN_IF_FAIL_OR_IGNORE;
        -: 1353:
        -: 1354:    /* if both pointers not null compare the strings */
       34: 1355:    if (expected && actual)
        -: 1356:    {
      284: 1357:        for (i = 0; expected[i] || actual[i]; i++)
        -: 1358:        {
      250: 1359:            if (expected[i] != actual[i])
        -: 1360:            {
    #####: 1361:                Unity.CurrentTestFailed = 1;
    #####: 1362:                break;
        -: 1363:            }
        -: 1364:        }
        -: 1365:    }
        -: 1366:    else
        -: 1367:    { /* handle case of one pointers being null (if both null, test should pass) */
    #####: 1368:        if (expected != actual)
        -: 1369:        {
    #####: 1370:            Unity.CurrentTestFailed = 1;
        -: 1371:        }
        -: 1372:    }
        -: 1373:
       34: 1374:    if (Unity.CurrentTestFailed)
        -: 1375:    {
    #####: 1376:        UnityTestResultsFailBegin(lineNumber);
    #####: 1377:        UnityPrintExpectedAndActualStrings(expected, actual);
    #####: 1378:        UnityAddMsgIfSpecified(msg);
    #####: 1379:        UNITY_FAIL_AND_BAIL;
        -: 1380:    }
       34: 1381:}
        -: 1382:
        -: 1383:/*-----------------------------------------------*/
    #####: 1384:void UnityAssertEqualStringLen(const char* expected,
        -: 1385:                               const char* actual,
        -: 1386:                               const UNITY_UINT32 length,
        -: 1387:                               const char* msg,
        -: 1388:                               const UNITY_LINE_TYPE lineNumber)
        -: 1389:{
        -: 1390:    UNITY_UINT32 i;
        -: 1391:
    #####: 1392:    RETURN_IF_FAIL_OR_IGNORE;
        -: 1393:
        -: 1394:    /* if both pointers not null compare the strings */
    #####: 1395:    if (expected && actual)
        -: 1396:    {
    #####: 1397:        for (i = 0; (i < length) && (expected[i] || actual[i]); i++)
        -: 1398:        {
    #####: 1399:            if (expected[i] != actual[i])
        -: 1400:            {
    #####: 1401:                Unity.CurrentTestFailed = 1;
    #####: 1402:                break;
        -: 1403:            }
        -: 1404:        }
        -: 1405:    }
        -: 1406:    else
        -: 1407:    { /* handle case of one pointers being null (if both null, test should pass) */
    #####: 1408:        if (expected != actual)
        -: 1409:        {
    #####: 1410:            Unity.CurrentTestFailed = 1;
        -: 1411:        }
        -: 1412:    }
        -: 1413:
    #####: 1414:    if (Unity.CurrentTestFailed)
        -: 1415:    {
    #####: 1416:        UnityTestResultsFailBegin(lineNumber);
    #####: 1417:        UnityPrintExpectedAndActualStringsLen(expected, actual, length);
    #####: 1418:        UnityAddMsgIfSpecified(msg);
    #####: 1419:        UNITY_FAIL_AND_BAIL;
        -: 1420:    }
    #####: 1421:}
        -: 1422:
        -: 1423:/*-----------------------------------------------*/
    #####: 1424:void UnityAssertEqualStringArray(UNITY_INTERNAL_PTR expected,
        -: 1425:                                 const char** actual,
        -: 1426:                                 const UNITY_UINT32 num_elements,
        -: 1427:                                 const char* msg,
        -: 1428:                                 const UNITY_LINE_TYPE lineNumber,
        -: 1429:                                 const UNITY_FLAGS_T flags)
        -: 1430:{
    #####: 1431:    UNITY_UINT32 i = 0;
    #####: 1432:    UNITY_UINT32 j = 0;
    #####: 1433:    const char* expd = NULL;
    #####: 1434:    const char* act = NULL;
        -: 1435:
    #####: 1436:    RETURN_IF_FAIL_OR_IGNORE;
        -: 1437:
        -: 1438:    /* if no elements, it's an error */
    #####: 1439:    if (num_elements == 0)
        -: 1440:    {
    #####: 1441:        UnityPrintPointlessAndBail();
        -: 1442:    }
        -: 1443:
    #####: 1444:    if ((const void*)expected == (const void*)actual)
        -: 1445:    {
    #####: 1446:        return; /* Both are NULL or same pointer */
        -: 1447:    }
        -: 1448:
    #####: 1449:    if (UnityIsOneArrayNull((UNITY_INTERNAL_PTR)expected, (UNITY_INTERNAL_PTR)actual, lineNumber, msg))
        -: 1450:    {
    #####: 1451:        UNITY_FAIL_AND_BAIL;
        -: 1452:    }
        -: 1453:
    #####: 1454:    if (flags != UNITY_ARRAY_TO_ARRAY)
        -: 1455:    {
    #####: 1456:        expd = (const char*)expected;
        -: 1457:    }
        -: 1458:
        -: 1459:    do
        -: 1460:    {
    #####: 1461:        act = actual[j];
    #####: 1462:        if (flags == UNITY_ARRAY_TO_ARRAY)
        -: 1463:        {
    #####: 1464:            expd = ((const char* const*)expected)[j];
        -: 1465:        }
        -: 1466:
        -: 1467:        /* if both pointers not null compare the strings */
    #####: 1468:        if (expd && act)
        -: 1469:        {
    #####: 1470:            for (i = 0; expd[i] || act[i]; i++)
        -: 1471:            {
    #####: 1472:                if (expd[i] != act[i])
        -: 1473:                {
    #####: 1474:                    Unity.CurrentTestFailed = 1;
    #####: 1475:                    break;
        -: 1476:                }
        -: 1477:            }
        -: 1478:        }
        -: 1479:        else
        -: 1480:        { /* handle case of one pointers being null (if both null, test should pass) */
    #####: 1481:            if (expd != act)
        -: 1482:            {
    #####: 1483:                Unity.CurrentTestFailed = 1;
        -: 1484:            }
        -: 1485:        }
        -: 1486:
    #####: 1487:        if (Unity.CurrentTestFailed)
        -: 1488:        {
    #####: 1489:            UnityTestResultsFailBegin(lineNumber);
    #####: 1490:            if (num_elements > 1)
        -: 1491:            {
    #####: 1492:                UnityPrint(UnityStrElement);
    #####: 1493:                UnityPrintNumberUnsigned(j);
        -: 1494:            }
    #####: 1495:            UnityPrintExpectedAndActualStrings(expd, act);
    #####: 1496:            UnityAddMsgIfSpecified(msg);
    #####: 1497:            UNITY_FAIL_AND_BAIL;
        -: 1498:        }
    #####: 1499:    } while (++j < num_elements);
        -: 1500:}
        -: 1501:
        -: 1502:/*-----------------------------------------------*/
    #####: 1503:void UnityAssertEqualMemory(UNITY_INTERNAL_PTR expected,
        -: 1504:                            UNITY_INTERNAL_PTR actual,
        -: 1505:                            const UNITY_UINT32 length,
        -: 1506:                            const UNITY_UINT32 num_elements,
        -: 1507:                            const char* msg,
        -: 1508:                            const UNITY_LINE_TYPE lineNumber,
        -: 1509:                            const UNITY_FLAGS_T flags)
        -: 1510:{
    #####: 1511:    UNITY_PTR_ATTRIBUTE const unsigned char* ptr_exp = (UNITY_PTR_ATTRIBUTE const unsigned char*)expected;
    #####: 1512:    UNITY_PTR_ATTRIBUTE const unsigned char* ptr_act = (UNITY_PTR_ATTRIBUTE const unsigned char*)actual;
    #####: 1513:    UNITY_UINT32 elements = num_elements;
        -: 1514:    UNITY_UINT32 bytes;
        -: 1515:
    #####: 1516:    RETURN_IF_FAIL_OR_IGNORE;
        -: 1517:
    #####: 1518:    if ((elements == 0) || (length == 0))
        -: 1519:    {
    #####: 1520:        UnityPrintPointlessAndBail();
        -: 1521:    }
        -: 1522:
    #####: 1523:    if (expected == actual)
        -: 1524:    {
    #####: 1525:        return; /* Both are NULL or same pointer */
        -: 1526:    }
        -: 1527:
    #####: 1528:    if (UnityIsOneArrayNull(expected, actual, lineNumber, msg))
        -: 1529:    {
    #####: 1530:        UNITY_FAIL_AND_BAIL;
        -: 1531:    }
        -: 1532:
    #####: 1533:    while (elements--)
        -: 1534:    {
    #####: 1535:        bytes = length;
    #####: 1536:        while (bytes--)
        -: 1537:        {
    #####: 1538:            if (*ptr_exp != *ptr_act)
        -: 1539:            {
    #####: 1540:                UnityTestResultsFailBegin(lineNumber);
    #####: 1541:                UnityPrint(UnityStrMemory);
    #####: 1542:                if (num_elements > 1)
        -: 1543:                {
    #####: 1544:                    UnityPrint(UnityStrElement);
    #####: 1545:                    UnityPrintNumberUnsigned(num_elements - elements - 1);
        -: 1546:                }
    #####: 1547:                UnityPrint(UnityStrByte);
    #####: 1548:                UnityPrintNumberUnsigned(length - bytes - 1);
    #####: 1549:                UnityPrint(UnityStrExpected);
    #####: 1550:                UnityPrintNumberByStyle(*ptr_exp, UNITY_DISPLAY_STYLE_HEX8);
    #####: 1551:                UnityPrint(UnityStrWas);
    #####: 1552:                UnityPrintNumberByStyle(*ptr_act, UNITY_DISPLAY_STYLE_HEX8);
    #####: 1553:                UnityAddMsgIfSpecified(msg);
    #####: 1554:                UNITY_FAIL_AND_BAIL;
        -: 1555:            }
    #####: 1556:            ptr_exp++;
    #####: 1557:            ptr_act++;
        -: 1558:        }
    #####: 1559:        if (flags == UNITY_ARRAY_TO_VAL)
        -: 1560:        {
    #####: 1561:            ptr_exp = (UNITY_PTR_ATTRIBUTE const unsigned char*)expected;
        -: 1562:        }
        -: 1563:    }
        -: 1564:}
        -: 1565:
        -: 1566:/*-----------------------------------------------*/
        -: 1567:
        -: 1568:static union
        -: 1569:{
        -: 1570:    UNITY_INT8 i8;
        -: 1571:    UNITY_INT16 i16;
        -: 1572:    UNITY_INT32 i32;
        -: 1573:#ifdef UNITY_SUPPORT_64
        -: 1574:    UNITY_INT64 i64;
        -: 1575:#endif
        -: 1576:#ifndef UNITY_EXCLUDE_FLOAT
        -: 1577:    float f;
        -: 1578:#endif
        -: 1579:#ifndef UNITY_EXCLUDE_DOUBLE
        -: 1580:    double d;
        -: 1581:#endif
        -: 1582:} UnityQuickCompare;
        -: 1583:
    #####: 1584:UNITY_INTERNAL_PTR UnityNumToPtr(const UNITY_INT num, const UNITY_UINT8 size)
        -: 1585:{
    #####: 1586:    switch(size)
        -: 1587:    {
    #####: 1588:        case 1:
    #####: 1589:            UnityQuickCompare.i8 = (UNITY_INT8)num;
    #####: 1590:            return (UNITY_INTERNAL_PTR)(&UnityQuickCompare.i8);
        -: 1591:
    #####: 1592:        case 2:
    #####: 1593:            UnityQuickCompare.i16 = (UNITY_INT16)num;
    #####: 1594:            return (UNITY_INTERNAL_PTR)(&UnityQuickCompare.i16);
        -: 1595:
        -: 1596:#ifdef UNITY_SUPPORT_64
    #####: 1597:        case 8:
    #####: 1598:            UnityQuickCompare.i64 = (UNITY_INT64)num;
    #####: 1599:            return (UNITY_INTERNAL_PTR)(&UnityQuickCompare.i64);
        -: 1600:#endif
        -: 1601:
    #####: 1602:        default: /* 4 bytes */
    #####: 1603:            UnityQuickCompare.i32 = (UNITY_INT32)num;
    #####: 1604:            return (UNITY_INTERNAL_PTR)(&UnityQuickCompare.i32);
        -: 1605:    }
        -: 1606:}
        -: 1607:
        -: 1608:#ifndef UNITY_EXCLUDE_FLOAT
        -: 1609:/*-----------------------------------------------*/
    #####: 1610:UNITY_INTERNAL_PTR UnityFloatToPtr(const float num)
        -: 1611:{
    #####: 1612:    UnityQuickCompare.f = num;
    #####: 1613:    return (UNITY_INTERNAL_PTR)(&UnityQuickCompare.f);
        -: 1614:}
        -: 1615:#endif
        -: 1616:
        -: 1617:#ifndef UNITY_EXCLUDE_DOUBLE
        -: 1618:/*-----------------------------------------------*/
    #####: 1619:UNITY_INTERNAL_PTR UnityDoubleToPtr(const double num)
        -: 1620:{
    #####: 1621:    UnityQuickCompare.d = num;
    #####: 1622:    return (UNITY_INTERNAL_PTR)(&UnityQuickCompare.d);
        -: 1623:}
        -: 1624:#endif
        -: 1625:
        -: 1626:/*-----------------------------------------------
        -: 1627: * printf helper function
        -: 1628: *-----------------------------------------------*/
        -: 1629:#ifdef UNITY_INCLUDE_PRINT_FORMATTED
        -: 1630:static void UnityPrintFVA(const char* format, va_list va)
        -: 1631:{
        -: 1632:    const char* pch = format;
        -: 1633:    if (pch != NULL)
        -: 1634:    {
        -: 1635:        while (*pch)
        -: 1636:        {
        -: 1637:            /* format identification character */
        -: 1638:            if (*pch == '%')
        -: 1639:            {
        -: 1640:                pch++;
        -: 1641:
        -: 1642:                if (pch != NULL)
        -: 1643:                {
        -: 1644:                    switch (*pch)
        -: 1645:                    {
        -: 1646:                        case 'd':
        -: 1647:                        case 'i':
        -: 1648:                            {
        -: 1649:                                const int number = va_arg(va, int);
        -: 1650:                                UnityPrintNumber((UNITY_INT)number);
        -: 1651:                                break;
        -: 1652:                            }
        -: 1653:#ifndef UNITY_EXCLUDE_FLOAT_PRINT
        -: 1654:                        case 'f':
        -: 1655:                        case 'g':
        -: 1656:                            {
        -: 1657:                                const double number = va_arg(va, double);
        -: 1658:                                UnityPrintFloat((UNITY_DOUBLE)number);
        -: 1659:                                break;
        -: 1660:                            }
        -: 1661:#endif
        -: 1662:                        case 'u':
        -: 1663:                            {
        -: 1664:                                const unsigned int number = va_arg(va, unsigned int);
        -: 1665:                                UnityPrintNumberUnsigned((UNITY_UINT)number);
        -: 1666:                                break;
        -: 1667:                            }
        -: 1668:                        case 'b':
        -: 1669:                            {
        -: 1670:                                const unsigned int number = va_arg(va, unsigned int);
        -: 1671:                                const UNITY_UINT mask = (UNITY_UINT)0 - (UNITY_UINT)1;
        -: 1672:                                UNITY_OUTPUT_CHAR('0');
        -: 1673:                                UNITY_OUTPUT_CHAR('b');
        -: 1674:                                UnityPrintMask(mask, (UNITY_UINT)number);
        -: 1675:                                break;
        -: 1676:                            }
        -: 1677:                        case 'x':
        -: 1678:                        case 'X':
        -: 1679:                        case 'p':
        -: 1680:                            {
        -: 1681:                                const unsigned int number = va_arg(va, unsigned int);
        -: 1682:                                UNITY_OUTPUT_CHAR('0');
        -: 1683:                                UNITY_OUTPUT_CHAR('x');
        -: 1684:                                UnityPrintNumberHex((UNITY_UINT)number, 8);
        -: 1685:                                break;
        -: 1686:                            }
        -: 1687:                        case 'c':
        -: 1688:                            {
        -: 1689:                                const int ch = va_arg(va, int);
        -: 1690:                                UnityPrintChar((const char *)&ch);
        -: 1691:                                break;
        -: 1692:                            }
        -: 1693:                        case 's':
        -: 1694:                            {
        -: 1695:                                const char * string = va_arg(va, const char *);
        -: 1696:                                UnityPrint(string);
        -: 1697:                                break;
        -: 1698:                            }
        -: 1699:                        case '%':
        -: 1700:                            {
        -: 1701:                                UnityPrintChar(pch);
        -: 1702:                                break;
        -: 1703:                            }
        -: 1704:                        default:
        -: 1705:                            {
        -: 1706:                                /* print the unknown format character */
        -: 1707:                                UNITY_OUTPUT_CHAR('%');
        -: 1708:                                UnityPrintChar(pch);
        -: 1709:                                break;
        -: 1710:                            }
        -: 1711:                    }
        -: 1712:                }
        -: 1713:            }
        -: 1714:#ifdef UNITY_OUTPUT_COLOR
        -: 1715:            /* print ANSI escape code */
        -: 1716:            else if ((*pch == 27) && (*(pch + 1) == '['))
        -: 1717:            {
        -: 1718:                pch += UnityPrintAnsiEscapeString(pch);
        -: 1719:                continue;
        -: 1720:            }
        -: 1721:#endif
        -: 1722:            else if (*pch == '\n')
        -: 1723:            {
        -: 1724:                UNITY_PRINT_EOL();
        -: 1725:            }
        -: 1726:            else
        -: 1727:            {
        -: 1728:                UnityPrintChar(pch);
        -: 1729:            }
        -: 1730:
        -: 1731:            pch++;
        -: 1732:        }
        -: 1733:    }
        -: 1734:}
        -: 1735:
        -: 1736:void UnityPrintF(const UNITY_LINE_TYPE line, const char* format, ...)
        -: 1737:{
        -: 1738:    UnityTestResultsBegin(Unity.TestFile, line);
        -: 1739:    UnityPrint("INFO");
        -: 1740:    if(format != NULL)
        -: 1741:    {
        -: 1742:        UnityPrint(": ");
        -: 1743:        va_list va;
        -: 1744:        va_start(va, format);
        -: 1745:        UnityPrintFVA(format, va);
        -: 1746:        va_end(va);
        -: 1747:    }
        -: 1748:    UNITY_PRINT_EOL();
        -: 1749:}
        -: 1750:#endif /* ! UNITY_INCLUDE_PRINT_FORMATTED */
        -: 1751:
        -: 1752:
        -: 1753:/*-----------------------------------------------
        -: 1754: * Control Functions
        -: 1755: *-----------------------------------------------*/
        -: 1756:
        -: 1757:/*-----------------------------------------------*/
    #####: 1758:void UnityFail(const char* msg, const UNITY_LINE_TYPE line)
        -: 1759:{
    #####: 1760:    RETURN_IF_FAIL_OR_IGNORE;
        -: 1761:
    #####: 1762:    UnityTestResultsBegin(Unity.TestFile, line);
    #####: 1763:    UnityPrint(UnityStrFail);
    #####: 1764:    if (msg != NULL)
        -: 1765:    {
    #####: 1766:        UNITY_OUTPUT_CHAR(':');
        -: 1767:
        -: 1768:#ifdef UNITY_PRINT_TEST_CONTEXT
        -: 1769:        UNITY_PRINT_TEST_CONTEXT();
        -: 1770:#endif
        -: 1771:#ifndef UNITY_EXCLUDE_DETAILS
    #####: 1772:        if (Unity.CurrentDetail1)
        -: 1773:        {
    #####: 1774:            UnityPrint(UnityStrDetail1Name);
    #####: 1775:            UnityPrint(Unity.CurrentDetail1);
    #####: 1776:            if (Unity.CurrentDetail2)
        -: 1777:            {
    #####: 1778:                UnityPrint(UnityStrDetail2Name);
    #####: 1779:                UnityPrint(Unity.CurrentDetail2);
        -: 1780:            }
    #####: 1781:            UnityPrint(UnityStrSpacer);
        -: 1782:        }
        -: 1783:#endif
    #####: 1784:        if (msg[0] != ' ')
        -: 1785:        {
    #####: 1786:            UNITY_OUTPUT_CHAR(' ');
        -: 1787:        }
    #####: 1788:        UnityPrint(msg);
        -: 1789:    }
        -: 1790:
    #####: 1791:    UNITY_FAIL_AND_BAIL;
        -: 1792:}
        -: 1793:
        -: 1794:/*-----------------------------------------------*/
    #####: 1795:void UnityIgnore(const char* msg, const UNITY_LINE_TYPE line)
        -: 1796:{
    #####: 1797:    RETURN_IF_FAIL_OR_IGNORE;
        -: 1798:
    #####: 1799:    UnityTestResultsBegin(Unity.TestFile, line);
    #####: 1800:    UnityPrint(UnityStrIgnore);
    #####: 1801:    if (msg != NULL)
        -: 1802:    {
    #####: 1803:        UNITY_OUTPUT_CHAR(':');
    #####: 1804:        UNITY_OUTPUT_CHAR(' ');
    #####: 1805:        UnityPrint(msg);
        -: 1806:    }
    #####: 1807:    UNITY_IGNORE_AND_BAIL;
        -: 1808:}
        -: 1809:
        -: 1810:/*-----------------------------------------------*/
    #####: 1811:void UnityMessage(const char* msg, const UNITY_LINE_TYPE line)
        -: 1812:{
    #####: 1813:    UnityTestResultsBegin(Unity.TestFile, line);
    #####: 1814:    UnityPrint("INFO");
    #####: 1815:    if (msg != NULL)
        -: 1816:    {
    #####: 1817:      UNITY_OUTPUT_CHAR(':');
    #####: 1818:      UNITY_OUTPUT_CHAR(' ');
    #####: 1819:      UnityPrint(msg);
        -: 1820:    }
    #####: 1821:    UNITY_PRINT_EOL();
    #####: 1822:}
        -: 1823:
        -: 1824:/*-----------------------------------------------*/
        -: 1825:/* If we have not defined our own test runner, then include our default test runner to make life easier */
        -: 1826:#ifndef UNITY_SKIP_DEFAULT_RUNNER
       52: 1827:void UnityDefaultTestRun(UnityTestFunction Func, const char* FuncName, const int FuncLineNum)
        -: 1828:{
       52: 1829:    Unity.CurrentTestName = FuncName;
       52: 1830:    Unity.CurrentTestLineNumber = (UNITY_LINE_TYPE)FuncLineNum;
       52: 1831:    Unity.NumberOfTests++;
       52: 1832:    UNITY_CLR_DETAILS();
        -: 1833:    UNITY_EXEC_TIME_START();
       52: 1834:    if (TEST_PROTECT())
        -: 1835:    {
       52: 1836:        setUp();
       52: 1837:        Func();
        -: 1838:    }
       52: 1839:    if (TEST_PROTECT())
        -: 1840:    {
       52: 1841:        tearDown();
        -: 1842:    }
        -: 1843:    UNITY_EXEC_TIME_STOP();
       52: 1844:    UnityConcludeTest();
       52: 1845:}
        -: 1846:#endif
        -: 1847:
        -: 1848:/*-----------------------------------------------*/
    #####: 1849:void UnitySetTestFile(const char* filename)
        -: 1850:{
    #####: 1851:	Unity.TestFile = filename;
    #####: 1852:}
        -: 1853:
        -: 1854:/*-----------------------------------------------*/
        2: 1855:void UnityBegin(const char* filename)
        -: 1856:{
        2: 1857:    Unity.TestFile = filename;
        2: 1858:    Unity.CurrentTestName = NULL;
        2: 1859:    Unity.CurrentTestLineNumber = 0;
        2: 1860:    Unity.NumberOfTests = 0;
        2: 1861:    Unity.TestFailures = 0;
        2: 1862:    Unity.TestIgnores = 0;
        2: 1863:    Unity.CurrentTestFailed = 0;
        2: 1864:    Unity.CurrentTestIgnored = 0;
        -: 1865:
        2: 1866:    UNITY_CLR_DETAILS();
        -: 1867:    UNITY_OUTPUT_START();
        2: 1868:}
        -: 1869:
        -: 1870:/*-----------------------------------------------*/
        2: 1871:int UnityEnd(void)
        -: 1872:{
        2: 1873:    UNITY_PRINT_EOL();
        2: 1874:    UnityPrint(UnityStrBreaker);
        2: 1875:    UNITY_PRINT_EOL();
        2: 1876:    UnityPrintNumber((UNITY_INT)(Unity.NumberOfTests));
        2: 1877:    UnityPrint(UnityStrResultsTests);
        2: 1878:    UnityPrintNumber((UNITY_INT)(Unity.TestFailures));
        2: 1879:    UnityPrint(UnityStrResultsFailures);
        2: 1880:    UnityPrintNumber((UNITY_INT)(Unity.TestIgnores));
        2: 1881:    UnityPrint(UnityStrResultsIgnored);
        2: 1882:    UNITY_PRINT_EOL();
        2: 1883:    if (Unity.TestFailures == 0U)
        -: 1884:    {
        2: 1885:        UnityPrint(UnityStrOk);
        -: 1886:    }
        -: 1887:    else
        -: 1888:    {
    #####: 1889:        UnityPrint(UnityStrFail);
        -: 1890:#ifdef UNITY_DIFFERENTIATE_FINAL_FAIL
        -: 1891:        UNITY_OUTPUT_CHAR('E'); UNITY_OUTPUT_CHAR('D');
        -: 1892:#endif
        -: 1893:    }
        2: 1894:    UNITY_PRINT_EOL();
        -: 1895:    UNITY_FLUSH_CALL();
        -: 1896:    UNITY_OUTPUT_COMPLETE();
        2: 1897:    return (int)(Unity.TestFailures);
        -: 1898:}
        -: 1899:
        -: 1900:/*-----------------------------------------------
        -: 1901: * Command Line Argument Support
        -: 1902: *-----------------------------------------------*/
        -: 1903:#ifdef UNITY_USE_COMMAND_LINE_ARGS
        -: 1904:
        -: 1905:char* UnityOptionIncludeNamed = NULL;
        -: 1906:char* UnityOptionExcludeNamed = NULL;
        -: 1907:int UnityVerbosity            = 1;
        -: 1908:
        -: 1909:/*-----------------------------------------------*/
        -: 1910:int UnityParseOptions(int argc, char** argv)
        -: 1911:{
        -: 1912:    int i;
        -: 1913:    UnityOptionIncludeNamed = NULL;
        -: 1914:    UnityOptionExcludeNamed = NULL;
        -: 1915:
        -: 1916:    for (i = 1; i < argc; i++)
        -: 1917:    {
        -: 1918:        if (argv[i][0] == '-')
        -: 1919:        {
        -: 1920:            switch (argv[i][1])
        -: 1921:            {
        -: 1922:                case 'l': /* list tests */
        -: 1923:                    return -1;
        -: 1924:                case 'n': /* include tests with name including this string */
        -: 1925:                case 'f': /* an alias for -n */
        -: 1926:                    if (argv[i][2] == '=')
        -: 1927:                    {
        -: 1928:                        UnityOptionIncludeNamed = &argv[i][3];
        -: 1929:                    }
        -: 1930:                    else if (++i < argc)
        -: 1931:                    {
        -: 1932:                        UnityOptionIncludeNamed = argv[i];
        -: 1933:                    }
        -: 1934:                    else
        -: 1935:                    {
        -: 1936:                        UnityPrint("ERROR: No Test String to Include Matches For");
        -: 1937:                        UNITY_PRINT_EOL();
        -: 1938:                        return 1;
        -: 1939:                    }
        -: 1940:                    break;
        -: 1941:                case 'q': /* quiet */
        -: 1942:                    UnityVerbosity = 0;
        -: 1943:                    break;
        -: 1944:                case 'v': /* verbose */
        -: 1945:                    UnityVerbosity = 2;
        -: 1946:                    break;
        -: 1947:                case 'x': /* exclude tests with name including this string */
        -: 1948:                    if (argv[i][2] == '=')
        -: 1949:                    {
        -: 1950:                        UnityOptionExcludeNamed = &argv[i][3];
        -: 1951:                    }
        -: 1952:                    else if (++i < argc)
        -: 1953:                    {
        -: 1954:                        UnityOptionExcludeNamed = argv[i];
        -: 1955:                    }
        -: 1956:                    else
        -: 1957:                    {
        -: 1958:                        UnityPrint("ERROR: No Test String to Exclude Matches For");
        -: 1959:                        UNITY_PRINT_EOL();
        -: 1960:                        return 1;
        -: 1961:                    }
        -: 1962:                    break;
        -: 1963:                default:
        -: 1964:                    UnityPrint("ERROR: Unknown Option ");
        -: 1965:                    UNITY_OUTPUT_CHAR(argv[i][1]);
        -: 1966:                    UNITY_PRINT_EOL();
        -: 1967:                    return 1;
        -: 1968:            }
        -: 1969:        }
        -: 1970:    }
        -: 1971:
        -: 1972:    return 0;
        -: 1973:}
        -: 1974:
        -: 1975:/*-----------------------------------------------*/
        -: 1976:int IsStringInBiggerString(const char* longstring, const char* shortstring)
        -: 1977:{
        -: 1978:    const char* lptr = longstring;
        -: 1979:    const char* sptr = shortstring;
        -: 1980:    const char* lnext = lptr;
        -: 1981:
        -: 1982:    if (*sptr == '*')
        -: 1983:    {
        -: 1984:        return 1;
        -: 1985:    }
        -: 1986:
        -: 1987:    while (*lptr)
        -: 1988:    {
        -: 1989:        lnext = lptr + 1;
        -: 1990:
        -: 1991:        /* If they current bytes match, go on to the next bytes */
        -: 1992:        while (*lptr && *sptr && (*lptr == *sptr))
        -: 1993:        {
        -: 1994:            lptr++;
        -: 1995:            sptr++;
        -: 1996:
        -: 1997:            /* We're done if we match the entire string or up to a wildcard */
        -: 1998:            if (*sptr == '*')
        -: 1999:                return 1;
        -: 2000:            if (*sptr == ',')
        -: 2001:                return 1;
        -: 2002:            if (*sptr == '"')
        -: 2003:                return 1;
        -: 2004:            if (*sptr == '\'')
        -: 2005:                return 1;
        -: 2006:            if (*sptr == ':')
        -: 2007:                return 2;
        -: 2008:            if (*sptr == 0)
        -: 2009:                return 1;
        -: 2010:        }
        -: 2011:
        -: 2012:        /* Otherwise we start in the long pointer 1 character further and try again */
        -: 2013:        lptr = lnext;
        -: 2014:        sptr = shortstring;
        -: 2015:    }
        -: 2016:
        -: 2017:    return 0;
        -: 2018:}
        -: 2019:
        -: 2020:/*-----------------------------------------------*/
        -: 2021:int UnityStringArgumentMatches(const char* str)
        -: 2022:{
        -: 2023:    int retval;
        -: 2024:    const char* ptr1;
        -: 2025:    const char* ptr2;
        -: 2026:    const char* ptrf;
        -: 2027:
        -: 2028:    /* Go through the options and get the substrings for matching one at a time */
        -: 2029:    ptr1 = str;
        -: 2030:    while (ptr1[0] != 0)
        -: 2031:    {
        -: 2032:        if ((ptr1[0] == '"') || (ptr1[0] == '\''))
        -: 2033:        {
        -: 2034:            ptr1++;
        -: 2035:        }
        -: 2036:
        -: 2037:        /* look for the start of the next partial */
        -: 2038:        ptr2 = ptr1;
        -: 2039:        ptrf = 0;
        -: 2040:        do
        -: 2041:        {
        -: 2042:            ptr2++;
        -: 2043:            if ((ptr2[0] == ':') && (ptr2[1] != 0) && (ptr2[0] != '\'') && (ptr2[0] != '"') && (ptr2[0] != ','))
        -: 2044:            {
        -: 2045:                ptrf = &ptr2[1];
        -: 2046:            }
        -: 2047:        } while ((ptr2[0] != 0) && (ptr2[0] != '\'') && (ptr2[0] != '"') && (ptr2[0] != ','));
        -: 2048:
        -: 2049:        while ((ptr2[0] != 0) && ((ptr2[0] == ':') || (ptr2[0] == '\'') || (ptr2[0] == '"') || (ptr2[0] == ',')))
        -: 2050:        {
        -: 2051:            ptr2++;
        -: 2052:        }
        -: 2053:
        -: 2054:        /* done if complete filename match */
        -: 2055:        retval = IsStringInBiggerString(Unity.TestFile, ptr1);
        -: 2056:        if (retval == 1)
        -: 2057:        {
        -: 2058:            return retval;
        -: 2059:        }
        -: 2060:
        -: 2061:        /* done if testname match after filename partial match */
        -: 2062:        if ((retval == 2) && (ptrf != 0))
        -: 2063:        {
        -: 2064:            if (IsStringInBiggerString(Unity.CurrentTestName, ptrf))
        -: 2065:            {
        -: 2066:                return 1;
        -: 2067:            }
        -: 2068:        }
        -: 2069:
        -: 2070:        /* done if complete testname match */
        -: 2071:        if (IsStringInBiggerString(Unity.CurrentTestName, ptr1) == 1)
        -: 2072:        {
        -: 2073:            return 1;
        -: 2074:        }
        -: 2075:
        -: 2076:        ptr1 = ptr2;
        -: 2077:    }
        -: 2078:
        -: 2079:    /* we couldn't find a match for any substrings */
        -: 2080:    return 0;
        -: 2081:}
        -: 2082:
        -: 2083:/*-----------------------------------------------*/
        -: 2084:int UnityTestMatches(void)
        -: 2085:{
        -: 2086:    /* Check if this test name matches the included test pattern */
        -: 2087:    int retval;
        -: 2088:    if (UnityOptionIncludeNamed)
        -: 2089:    {
        -: 2090:        retval = UnityStringArgumentMatches(UnityOptionIncludeNamed);
        -: 2091:    }
        -: 2092:    else
        -: 2093:    {
        -: 2094:        retval = 1;
        -: 2095:    }
        -: 2096:
        -: 2097:    /* Check if this test name matches the excluded test pattern */
        -: 2098:    if (UnityOptionExcludeNamed)
        -: 2099:    {
        -: 2100:        if (UnityStringArgumentMatches(UnityOptionExcludeNamed))
        -: 2101:        {
        -: 2102:            retval = 0;
        -: 2103:        }
        -: 2104:    }
        -: 2105:
        -: 2106:    return retval;
        -: 2107:}
        -: 2108:
        -: 2109:#endif /* UNITY_USE_COMMAND_LINE_ARGS */
        -: 2110:/*-----------------------------------------------*/
