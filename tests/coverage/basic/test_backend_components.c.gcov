        -:    0:Source:/home/nikolas/Programming/repos/im-c/tests/backend/test_backend_components.c
        -:    0:Graph:build/CMakeFiles/test_backend_components.dir/backend/test_backend_components.c.gcno
        -:    0:Data:build/CMakeFiles/test_backend_components.dir/backend/test_backend_components.c.gcda
        -:    0:Runs:2
        -:    1:#include "unity.h"
        -:    2:#include <stdlib.h>
        -:    3:#include <string.h>
        -:    4:#include <stdio.h>
        -:    5:
        -:    6:/* Mock structures based on protocol_lws_minimal.c */
        -:    7:struct msg {
        -:    8:    void *payload;
        -:    9:    size_t len;
        -:   10:    uint64_t timestamp;
        -:   11:    struct msg *next;
        -:   12:};
        -:   13:
        -:   14:struct per_session_data__minimal {
        -:   15:    struct per_session_data__minimal *pss_list;
        -:   16:    void *wsi; /* Mocked as void* for testing */
        -:   17:    int last;
        -:   18:    int needs_history;
        -:   19:    struct msg *history_pos;
        -:   20:};
        -:   21:
        -:   22:struct per_vhost_data__minimal {
        -:   23:    void *context; /* Mocked */
        -:   24:    void *vhost;   /* Mocked */
        -:   25:    void *protocol; /* Mocked */
        -:   26:    
        -:   27:    struct per_session_data__minimal *pss_list;
        -:   28:    
        -:   29:    struct msg amsg;
        -:   30:    int current;
        -:   31:    
        -:   32:    /* Message history */
        -:   33:    struct msg *message_history_head;
        -:   34:    struct msg *message_history_tail;
        -:   35:    int message_count;
        -:   36:    int max_history_messages;
        -:   37:};
        -:   38:
        -:   39:/* Test implementations of backend functions */
        4:   40:static void __minimal_destroy_message(void *_msg) {
        4:   41:    struct msg *msg = _msg;
        4:   42:    if (msg && msg->payload) {
        4:   43:        free(msg->payload);
        4:   44:        msg->payload = NULL;
        4:   45:        msg->len = 0;
        -:   46:    }
        4:   47:}
        -:   48:
       34:   49:static void __minimal_add_to_history(struct per_vhost_data__minimal *vhd, void *payload, size_t len) {
        -:   50:    struct msg *new_msg;
        -:   51:    
       34:   52:    if (!vhd || !payload || len == 0) return;
        -:   53:    
       28:   54:    new_msg = malloc(sizeof(struct msg));
      28*:   55:    if (!new_msg) return;
        -:   56:
       28:   57:    new_msg->payload = malloc(len + 16 + 1); /* LWS_PRE simulation + null terminator */
       28:   58:    if (!new_msg->payload) {
    #####:   59:        free(new_msg);
    #####:   60:        return;
        -:   61:    }
        -:   62:
       28:   63:    memcpy((char *)new_msg->payload + 16, payload, len);
       28:   64:    ((char *)new_msg->payload + 16)[len] = '\0'; /* Null terminate string */
       28:   65:    new_msg->len = len;
       28:   66:    new_msg->timestamp = 1234567890; /* Mock timestamp */
       28:   67:    new_msg->next = NULL;
        -:   68:
        -:   69:    /* Add to tail of history list */
       28:   70:    if (vhd->message_history_tail) {
       18:   71:        vhd->message_history_tail->next = new_msg;
        -:   72:    } else {
       10:   73:        vhd->message_history_head = new_msg;
        -:   74:    }
       28:   75:    vhd->message_history_tail = new_msg;
       28:   76:    vhd->message_count++;
        -:   77:
        -:   78:    /* Remove old messages if we exceed limit */
       32:   79:    while (vhd->message_count > vhd->max_history_messages && vhd->message_history_head) {
        4:   80:        struct msg *old_head = vhd->message_history_head;
        4:   81:        vhd->message_history_head = vhd->message_history_head->next;
        4:   82:        if (!vhd->message_history_head) {
    #####:   83:            vhd->message_history_tail = NULL;
        -:   84:        }
        4:   85:        free(old_head->payload);
        4:   86:        free(old_head);
        4:   87:        vhd->message_count--;
        -:   88:    }
        -:   89:}
        -:   90:
        -:   91:/* Test helper functions */
       14:   92:static struct per_vhost_data__minimal* create_test_vhd(void) {
       14:   93:    struct per_vhost_data__minimal *vhd = calloc(1, sizeof(struct per_vhost_data__minimal));
       14:   94:    if (vhd) {
       14:   95:        vhd->max_history_messages = 5; /* Small limit for testing */
       14:   96:        vhd->message_count = 0;
       14:   97:        vhd->message_history_head = NULL;
       14:   98:        vhd->message_history_tail = NULL;
       14:   99:        vhd->current = 0;
        -:  100:    }
       14:  101:    return vhd;
        -:  102:}
        -:  103:
       14:  104:static void destroy_test_vhd(struct per_vhost_data__minimal *vhd) {
        -:  105:    struct msg *current, *next;
        -:  106:    
      14*:  107:    if (!vhd) return;
        -:  108:    
        -:  109:    /* Clean up message history */
       14:  110:    current = vhd->message_history_head;
       36:  111:    while (current) {
       22:  112:        next = current->next;
       22:  113:        if (current->payload) {
       22:  114:            free(current->payload);
        -:  115:        }
       22:  116:        free(current);
       22:  117:        current = next;
        -:  118:    }
        -:  119:    
        -:  120:    /* Clean up current message */
       14:  121:    if (vhd->amsg.payload) {
    #####:  122:        free(vhd->amsg.payload);
        -:  123:    }
        -:  124:    
       14:  125:    free(vhd);
        -:  126:}
        -:  127:
        2:  128:static struct per_session_data__minimal* create_test_pss(void) {
        2:  129:    struct per_session_data__minimal *pss = calloc(1, sizeof(struct per_session_data__minimal));
        2:  130:    if (pss) {
        2:  131:        pss->wsi = (void*)0x12345678; /* Mock WSI pointer */
        2:  132:        pss->last = 0;
        2:  133:        pss->needs_history = 0;
        2:  134:        pss->history_pos = NULL;
        -:  135:    }
        2:  136:    return pss;
        -:  137:}
        -:  138:
        -:  139:/* Test cases */
       20:  140:void setUp(void) {
        -:  141:    /* Setup before each test */
       20:  142:}
        -:  143:
       20:  144:void tearDown(void) {
        -:  145:    /* Cleanup after each test */
       20:  146:}
        -:  147:
        2:  148:void test_minimal_destroy_message(void) {
        -:  149:    struct msg test_msg;
        2:  150:    char *test_payload = malloc(32);
        -:  151:    
        2:  152:    strcpy(test_payload, "Test message");
        2:  153:    test_msg.payload = test_payload;
        2:  154:    test_msg.len = strlen("Test message");
        -:  155:    
        2:  156:    __minimal_destroy_message(&test_msg);
        -:  157:    
       2*:  158:    TEST_ASSERT_NULL(test_msg.payload);
        2:  159:    TEST_ASSERT_EQUAL_INT(0, test_msg.len);
        2:  160:}
        -:  161:
        2:  162:void test_minimal_add_to_history_single_message(void) {
        2:  163:    struct per_vhost_data__minimal *vhd = create_test_vhd();
        2:  164:    const char *test_message = "Hello World";
        -:  165:    
        2:  166:    __minimal_add_to_history(vhd, (void*)test_message, strlen(test_message));
        -:  167:    
        2:  168:    TEST_ASSERT_EQUAL_INT(1, vhd->message_count);
       2*:  169:    TEST_ASSERT_NOT_NULL(vhd->message_history_head);
        2:  170:    TEST_ASSERT_EQUAL_PTR(vhd->message_history_head, vhd->message_history_tail);
        2:  171:    TEST_ASSERT_EQUAL_INT(strlen(test_message), vhd->message_history_head->len);
        -:  172:    
        -:  173:    /* Check message content (offset by LWS_PRE simulation) */
        2:  174:    char *stored_message = (char*)vhd->message_history_head->payload + 16;
        2:  175:    TEST_ASSERT_EQUAL_STRING(test_message, stored_message);
        -:  176:    
        2:  177:    destroy_test_vhd(vhd);
        2:  178:}
        -:  179:
        2:  180:void test_minimal_add_to_history_multiple_messages(void) {
        2:  181:    struct per_vhost_data__minimal *vhd = create_test_vhd();
        2:  182:    const char *messages[] = {"Message 1", "Message 2", "Message 3"};
        -:  183:    int i;
        -:  184:    struct msg *current;
        -:  185:    
        8:  186:    for (i = 0; i < 3; i++) {
        6:  187:        __minimal_add_to_history(vhd, (void*)messages[i], strlen(messages[i]));
        -:  188:    }
        -:  189:    
        2:  190:    TEST_ASSERT_EQUAL_INT(3, vhd->message_count);
       2*:  191:    TEST_ASSERT_NOT_NULL(vhd->message_history_head);
       2*:  192:    TEST_ASSERT_NOT_NULL(vhd->message_history_tail);
       2*:  193:    TEST_ASSERT_NOT_EQUAL(vhd->message_history_head, vhd->message_history_tail);
        -:  194:    
        -:  195:    /* Verify message order */
        2:  196:    current = vhd->message_history_head;
        8:  197:    for (i = 0; i < 3; i++) {
       6*:  198:        TEST_ASSERT_NOT_NULL(current);
        6:  199:        char *stored_message = (char*)current->payload + 16;
        6:  200:        TEST_ASSERT_EQUAL_STRING(messages[i], stored_message);
        6:  201:        current = current->next;
        -:  202:    }
        -:  203:    
        2:  204:    destroy_test_vhd(vhd);
        2:  205:}
        -:  206:
        2:  207:void test_minimal_add_to_history_overflow(void) {
        2:  208:    struct per_vhost_data__minimal *vhd = create_test_vhd();
        2:  209:    const char *messages[] = {"Msg1", "Msg2", "Msg3", "Msg4", "Msg5", "Msg6", "Msg7"};
        -:  210:    int i;
        -:  211:    struct msg *current;
        -:  212:    
        -:  213:    /* Add more messages than max_history_messages (5) */
       16:  214:    for (i = 0; i < 7; i++) {
       14:  215:        __minimal_add_to_history(vhd, (void*)messages[i], strlen(messages[i]));
        -:  216:    }
        -:  217:    
        -:  218:    /* Should only keep the last 5 messages */
        2:  219:    TEST_ASSERT_EQUAL_INT(5, vhd->message_count);
        -:  220:    
        -:  221:    /* Verify we have the last 5 messages (Msg3, Msg4, Msg5, Msg6, Msg7) */
        2:  222:    current = vhd->message_history_head;
       12:  223:    for (i = 2; i < 7; i++) { /* Start from index 2 (Msg3) */
      10*:  224:        TEST_ASSERT_NOT_NULL(current);
       10:  225:        char *stored_message = (char*)current->payload + 16;
       10:  226:        TEST_ASSERT_EQUAL_STRING(messages[i], stored_message);
       10:  227:        current = current->next;
        -:  228:    }
        -:  229:    
        2:  230:    destroy_test_vhd(vhd);
        2:  231:}
        -:  232:
        2:  233:void test_minimal_add_to_history_null_inputs(void) {
        2:  234:    struct per_vhost_data__minimal *vhd = create_test_vhd();
        -:  235:    
        -:  236:    /* Test with NULL payload */
        2:  237:    __minimal_add_to_history(vhd, NULL, 10);
        2:  238:    TEST_ASSERT_EQUAL_INT(0, vhd->message_count);
        -:  239:    
        -:  240:    /* Test with zero length */
        2:  241:    __minimal_add_to_history(vhd, "test", 0);
        2:  242:    TEST_ASSERT_EQUAL_INT(0, vhd->message_count);
        -:  243:    
        -:  244:    /* Test with NULL vhd */
        2:  245:    __minimal_add_to_history(NULL, "test", 4);
        -:  246:    /* Should not crash */
        -:  247:    
        2:  248:    destroy_test_vhd(vhd);
        2:  249:}
        -:  250:
        2:  251:void test_session_initialization(void) {
        2:  252:    struct per_session_data__minimal *pss = create_test_pss();
        -:  253:    
       2*:  254:    TEST_ASSERT_NOT_NULL(pss);
        2:  255:    TEST_ASSERT_EQUAL_INT(0, pss->last);
        2:  256:    TEST_ASSERT_EQUAL_INT(0, pss->needs_history);
       2*:  257:    TEST_ASSERT_NULL(pss->history_pos);
       2*:  258:    TEST_ASSERT_NOT_NULL(pss->wsi);
        -:  259:    
        2:  260:    free(pss);
        2:  261:}
        -:  262:
        2:  263:void test_vhost_data_initialization(void) {
        2:  264:    struct per_vhost_data__minimal *vhd = create_test_vhd();
        -:  265:    
       2*:  266:    TEST_ASSERT_NOT_NULL(vhd);
        2:  267:    TEST_ASSERT_EQUAL_INT(5, vhd->max_history_messages);
        2:  268:    TEST_ASSERT_EQUAL_INT(0, vhd->message_count);
       2*:  269:    TEST_ASSERT_NULL(vhd->message_history_head);
       2*:  270:    TEST_ASSERT_NULL(vhd->message_history_tail);
        2:  271:    TEST_ASSERT_EQUAL_INT(0, vhd->current);
       2*:  272:    TEST_ASSERT_NULL(vhd->amsg.payload);
        -:  273:    
        2:  274:    destroy_test_vhd(vhd);
        2:  275:}
        -:  276:
        2:  277:void test_message_structure_integrity(void) {
        -:  278:    struct msg test_msg;
        2:  279:    const char *test_payload = "Test message for integrity check";
        -:  280:    
        2:  281:    test_msg.payload = malloc(strlen(test_payload) + 1);
        2:  282:    strcpy(test_msg.payload, test_payload);
        2:  283:    test_msg.len = strlen(test_payload);
        2:  284:    test_msg.timestamp = 1234567890;
        2:  285:    test_msg.next = NULL;
        -:  286:    
       2*:  287:    TEST_ASSERT_NOT_NULL(test_msg.payload);
        2:  288:    TEST_ASSERT_EQUAL_INT(strlen(test_payload), test_msg.len);
        2:  289:    TEST_ASSERT_EQUAL_STRING(test_payload, (char*)test_msg.payload);
        2:  290:    TEST_ASSERT_EQUAL_UINT64(1234567890, test_msg.timestamp);
       2*:  291:    TEST_ASSERT_NULL(test_msg.next);
        -:  292:    
        2:  293:    free(test_msg.payload);
        2:  294:}
        -:  295:
        2:  296:void test_linked_list_operations(void) {
        2:  297:    struct per_vhost_data__minimal *vhd = create_test_vhd();
        2:  298:    const char *first_msg = "First";
        2:  299:    const char *second_msg = "Second";
        -:  300:    
        -:  301:    /* Add first message */
        2:  302:    __minimal_add_to_history(vhd, (void*)first_msg, strlen(first_msg));
        2:  303:    TEST_ASSERT_EQUAL_PTR(vhd->message_history_head, vhd->message_history_tail);
       2*:  304:    TEST_ASSERT_NULL(vhd->message_history_head->next);
        -:  305:    
        -:  306:    /* Add second message */
        2:  307:    __minimal_add_to_history(vhd, (void*)second_msg, strlen(second_msg));
       2*:  308:    TEST_ASSERT_NOT_EQUAL(vhd->message_history_head, vhd->message_history_tail);
        2:  309:    TEST_ASSERT_EQUAL_PTR(vhd->message_history_head->next, vhd->message_history_tail);
       2*:  310:    TEST_ASSERT_NULL(vhd->message_history_tail->next);
        -:  311:    
        2:  312:    destroy_test_vhd(vhd);
        2:  313:}
        -:  314:
        2:  315:void test_memory_management(void) {
        2:  316:    struct per_vhost_data__minimal *vhd = create_test_vhd();
        2:  317:    const char *test_message = "Memory test message";
        -:  318:    void *original_payload;
        -:  319:    
        -:  320:    /* Add message and verify payload allocation */
        2:  321:    __minimal_add_to_history(vhd, (void*)test_message, strlen(test_message));
       2*:  322:    TEST_ASSERT_NOT_NULL(vhd->message_history_head->payload);
        -:  323:    
        2:  324:    original_payload = vhd->message_history_head->payload;
        -:  325:    
        -:  326:    /* Destroy message and verify cleanup */
        2:  327:    __minimal_destroy_message(vhd->message_history_head);
       2*:  328:    TEST_ASSERT_NULL(vhd->message_history_head->payload);
        2:  329:    TEST_ASSERT_EQUAL_INT(0, vhd->message_history_head->len);
        -:  330:    
        -:  331:    /* Cleanup */
        2:  332:    free(vhd->message_history_head);
        2:  333:    vhd->message_history_head = NULL;
        2:  334:    vhd->message_history_tail = NULL;
        2:  335:    vhd->message_count = 0;
        -:  336:    
        2:  337:    destroy_test_vhd(vhd);
        2:  338:}
        -:  339:
        2:  340:int main(void) {
        2:  341:    UNITY_BEGIN();
        -:  342:    
        -:  343:    /* Message management tests */
        2:  344:    RUN_TEST(test_minimal_destroy_message);
        2:  345:    RUN_TEST(test_minimal_add_to_history_single_message);
        2:  346:    RUN_TEST(test_minimal_add_to_history_multiple_messages);
        2:  347:    RUN_TEST(test_minimal_add_to_history_overflow);
        2:  348:    RUN_TEST(test_minimal_add_to_history_null_inputs);
        -:  349:    
        -:  350:    /* Data structure tests */
        2:  351:    RUN_TEST(test_session_initialization);
        2:  352:    RUN_TEST(test_vhost_data_initialization);
        2:  353:    RUN_TEST(test_message_structure_integrity);
        -:  354:    
        -:  355:    /* Internal logic tests */
        2:  356:    RUN_TEST(test_linked_list_operations);
        2:  357:    RUN_TEST(test_memory_management);
        -:  358:    
        2:  359:    return UNITY_END();
        -:  360:}
